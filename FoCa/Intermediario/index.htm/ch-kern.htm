<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">

<title>Guia Foca GNU/Linux - Kernel e Módulos</title>

</head>

<body>

<a name="ch-kern"></a>
<hr>

[ <a href="ch-rede.htm">anterior</a> ]
[ <a href="index.htm#contents">Conteúdo</a> ]
[ <a href="ch-intro.htm">1</a> ]
[ <a href="ch-bas.htm">2</a> ]
[ <a href="ch-hardw.htm">3</a> ]
[ <a href="ch-d-l.htm">4</a> ]
[ <a href="ch-disc.htm">5</a> ]
[ <a href="ch-boot.htm">6</a> ]
[ <a href="ch-run.htm">7</a> ]
[ <a href="ch-cmdd.htm">8</a> ]
[ <a href="ch-cmd.htm">9</a> ]
[ <a href="ch-cmdv.htm">10</a> ]
[ <a href="ch-cmdn.htm">11</a> ]
[ <a href="ch-cmdc.htm">12</a> ]
[ <a href="ch-perm.htm">13</a> ]
[ <a href="ch-redir.htm">14</a> ]
[ <a href="ch-rede.htm">15</a> ]
[ 16 ]
[ <a href="ch-log.htm">17</a> ]
[ <a href="ch-cpctd.htm">18</a> ]
[ <a href="ch-deb.htm">19</a> ]
[ <a href="ch-dpkg.htm">20</a> ]
[ <a href="ch-pers.htm">21</a> ]
[ <a href="ch-impr.htm">22</a> ]
[ <a href="ch-cfg.htm">23</a> ]
[ <a href="ch-tasks.htm">24</a> ]
[ <a href="ch-compil.htm">25</a> ]
[ <a href="ch-manut.htm">26</a> ]
[ <a href="ch-etc.htm">27</a> ]
[ <a href="ch-inter.htm">28</a> ]
[ <a href="ch-x11.htm">29</a> ]
[ <a href="ch-aplic.htm">30</a> ]
[ <a href="ch-ajuda.htm">31</a> ]
[ <a href="ch-apend.htm">32</a> ]
[ <a href="ch-log.htm">próximo</a> ]

<hr>

<h1>
Guia Foca GNU/Linux
<br>Capítulo 16 - Kernel e Módulos
</h1>

<hr>

<p>
Este capítulo descreve em detalhes o que é o kernel, módulos, sua configuração
e programas relacionados.

<hr>

<a name="s-kern-kernel"></a>
<h2>16.1 O Kernel</h2>

<p>
É o sistema operacional (o <code>Linux</code>), é ele que controla os
dispositivos e demais periféricos do sistema (como memória, placas de som,
vídeo, discos rígidos, disquetes, sistemas de arquivos, redes e outros recursos
disponíveis).  Muitos confundem isto e chamam a distribuição de sistema
operacional.  Isto é errado!

<p>
O <em>kernel</em> faz o controle dos periféricos do sistema e para isto ele
deve ter o seu suporte incluído.  Para fazer uma placa de som <em>Sound
Blaster</em> funcionar, por exemplo, é necessário que o kernel ofereça suporte
a este placa e você deve configurar seus parâmetros (como interrupção, I/O e
DMA) com comandos específicos para ativar a placa e faze-la funcionar
corretamente.  Existe um documento que contém quais são os periféricos
suportados/ não suportados pelo <code>GNU/Linux</code>, ele se chama
<samp>Hardware-HOWTO</samp>.

<p>
Suas versões são identificadas por números como 2.0.36, 2.0.38, 2.1.10, 2.2.12,
as versões que contém um número par entre o primeiro e segundo ponto são
versões estáveis e que contém números ímpares neste mesmo local são versões
instáveis (em desenvolvimento).  Usar versões instáveis não quer dizer que
ocorrerá travamentos ou coisas do tipo, mas algumas partes do kernel podem não
estar testadas o suficiente ou alguns controladores podem ainda estar
incompletos para obter pleno funcionamento.  Se opera sua máquina em um
ambiente crítico, prefira pegar versões estáveis do kernel.

<p>
Após inicializar o sistema, o kernel e seus arquivos podem ser acessados ou
modificados através do ponto de montagem <code>/proc</code>.  Para detalhes
veja <a href="ch-disc.htm#s-disc-proc">O sistema de arquivos
<code>/proc</code>, Seção 5.8</a>.

<p>
Caso você tenha um dispositivo (como uma placa de som) que tem suporte no
<code>GNU/Linux</code> mas não funciona veja <a href="#s-kern-suporte">Como
adicionar suporte a Hardwares e outros dispositivos no kernel, Seção 16.3</a>.

<hr>

<a name="s-kern-modulos"></a>
<h2>16.2 Módulos</h2>

<p>
São partes do kernel que são carregadas somente quando são solicitadas por
algum aplicativo ou dispositivo e descarregadas da memória quando não são mais
usadas.  Este recurso é útil por 2 motivos: Evita a construção de um kernel
grande (estático) que ocupe grande parte da memória com todos os drivers
compilados e permite que partes do kernel ocupem a memória somente quando forem
necessários.

<p>
Os módulos do kernel estão localizados no diretório
<code>/lib/modules/versão_do_kernel/*</code> (onde
<samp>versão_do_kernel</samp> é a versão atual do kernel em seu sistema, caso
seja <samp>2.2.10</samp> o diretório que contém seus módulos será
<code>/lib/modules/2.2.10</code>.

<p>
Os módulos são carregados automaticamente quando solicitados através do
programa <code>kmod</code> ou manualmente através do arquivo
<code>/etc/modules</code> , <code>insmod</code> ou <code>modprobe</code>.
Atenção: Não compile o suporte ao seu sistema de arquivos raíz como módulo,
isto o tornará inacessível.

<hr>

<a name="s-kern-suporte"></a>
<h2>16.3 Como adicionar suporte a Hardwares e outros dispositivos no kernel</h2>

<p>
Quando seu hardware não funciona mas você tem certeza que é suportado pelo
<code>GNU/Linux</code>, é preciso seguir alguns passos para faze-lo funcionar
corretamente:
<ul>
<li>
Verifique se o kernel atual foi compilado com suporte ao seu dispositivo.
Também é possível que o suporte ao dispositivo esteja compilado como módulo.
Dê o comando <samp>dmesg</samp> para ver as mensagens do kernel durante a
inicialização e verifique se aparece alguma coisa referente ao dispositivo que
deseja instalar (alguma mensagem de erro, etc).  Caso não aparecer nada é
possível que o driver esteja compilado como módulo, para verificar isto entre
no diretório <code>/lib/modules/versao_do_kernel</code> e veja se encontra o
módulo correspondente ao seu dispositivo (o módulo da placa <em>NE 2000</em>
tem o nome de <code>ne.o</code> e o da placa <em>Sound Blaster</em> de
<code>sb.o</code>, por exemplo).

<p>
Caso o kernel não tiver o suporte ao seu dispositivo, você precisará recompilar
seu kernel ativando seu suporte.  Veja <a
href="#s-kern-recompilando">Recompilando o Kernel, Seção 16.11</a>.
</li>
</ul>
<ul>
<li>
Caso seu hardware esteja compilado no kernel, verifique se o módulo
correspondente está carregado (com o comando <code>lsmod</code>).  Caso não
estiver, carregue-o com o <code>modprobe</code> (por exemplo, <samp>modprobe sb
io=0x220 irq=5 dma=1 dma16=5 mpuio=0x330</samp>), para detalhes veja <a
href="#s-kern-modprobe">modprobe, Seção 16.8</a>.

<p>
O uso deste comando deverá ativar seu hardware imediatamente, neste caso
configure o módulo para ser carregado automaticamente através do programa
<code>modconf</code> ou edite os arquivos relacionados com os módulos (veja <a
href="#s-kern-arquivos">Arquivos relacionados com o Kernel e Módulos, Seção
16.12</a>).  Caso não tenha sucesso, será retornada uma mensagem de erro.
</li>
</ul>

<hr>

<a name="s-kern-kmod"></a>
<h2>16.4 kmod</h2>

<p>
Este é o programa usado para carregar os módulos automaticamente quando são
requeridos pelo sistema.  Ele é um daemon que funciona constantemente fazendo a
monitoração, quando verifica que algum dispositivo ou programa está solicitando
o suporte a algum dispositivo, ele carrega o módulo correspondente.

<p>
Ele pode ser desativado através da recompilação do kernel, dando um
<code>kill</code> no processo ou através do arquivo <code>/etc/modules</code>
(veja <a href="#s-kern-arquivos-modules">/etc/modules, Seção 16.12.1</a>.  Caso
seja desativado, é preciso carregar manualmente os módulos através do
<code>modprobe</code> ou <code>insmod</code>.

<hr>

<a name="s-kern-lsmod"></a>
<h2>16.5 lsmod</h2>

<p>
Lista quais módulos estão carregados atualmente pelo kernel.  O nome
<samp>lsmod</samp> é uma contração de <samp>ls</samp>+<samp>módulos</samp> -
Listar Módulos.  A listagem feita pelo <code>lsmod</code> é uma alternativa ao
uso do comando <samp>cat /proc/modules</samp>.

<p>
A saída deste comando tem a seguinte forma:

<pre>
     Module            Size  Pages    Used by
     nls_iso8859_1     8000      1          1 (autoclean)
     nls_cp437         3744      1          1 (autoclean)
     ne                6156      2          1
     8390              8390      2     [ne] 0
</pre>

<p>
A coluna <em>Module</em> indica o nome do módulo que está carregado, a coluna
<em>Used</em> mostra qual módulos está usando aquele recurso.  O parâmetro
<em>(autoclean)</em> no final da coluna indica que o módulo foi carregado
manualmente (pelo <code>insmod</code> ou <code>modprobe</code>) ou através do
<code>kmod</code> e será automaticamente removido da memória quando não for
mais usado.

<p>
No exemplo acima os módulos <em>ne</em> e <em>8390</em> não tem o parâmetro
<em>(autoclean)</em> porque foram carregados pelo arquivo
<code>/etc/modules</code> (veja <a
href="#s-kern-arquivos-modules">/etc/modules, Seção 16.12.1</a>).  Isto
significa que não serão removidos da memória caso estiverem sem uso.

<p>
Qualquer módulo carregado pode ser removido manualmente através do comandos
<code>rmmod</code>.

<hr>

<a name="s-kern-insmod"></a>
<h2>16.6 insmod</h2>

<p>
Carrega um módulo manualmente.  Para carregar módulos que dependem de outros
módulos para que funcionem, você duas opções: Carregar os módulos manualmente
ou usar o <code>modprobe</code> que verifica e carrega as dependências
correspondentes.

<p>
A sintaxe do comando é: <samp>insmod [<em>módulo</em>]
[<em>opções_módulo</em>]</samp>

<p>
Onde:
<dl>
<dt>módulo</dt>
<dd>
É o nome do módulo que será carregado.
</dd>
<dt>opções_módulo</dt>
<dd>
Opções que serão usadas pelo módulo.  Variam de módulo para módulo, alguns
precisam de opções outros não, tente primeiro carregar sem opções, caso seja
mostrada uma mensagem de erro verifique as opções usadas por ele.  Para
detalhes sobre que opções são suportadas por cada módulo, veja a sua
documentação no código fonte do kernel em
<code>/usr/src/linux/Documentation</code>
</dd>
</dl>

<p>
Exemplo: <samp>insmod ne io=0x300 irq=10</samp>

<hr>

<a name="s-kern-rmmod"></a>
<h2>16.7 rmmod</h2>

<p>
Remove módulos carregados no kernel.  Para ver os nomes dos módulos atualmente
carregados no kernel digite <samp>lsmod</samp> e verifique na primeira coluna o
nome do módulo.  Caso um módulo tenha dependências e você tentar remover suas
dependências, uma mensagem de erro será mostrada alertando que o módulo está em
uso.

<p>
Exemplo: <samp>rmmod ne</samp>

<hr>

<a name="s-kern-modprobe"></a>
<h2>16.8 modprobe</h2>

<p>
Carrega um módulo e suas dependências manualmente.  Este comando permite
carregar diversos módulos e dependências de uma só vez.  O comportamento do
<code>modprobe</code> é modificado pelo arquivo <code>/etc/modules.conf</code>
.

<p>
A sintaxe deste comando é: <samp>modprobe [<em>módulo</em>]
[<em>opções_módulo</em>]</samp>

<p>
Onde:
<dl>
<dt>módulo</dt>
<dd>
É o nome do módulo que será carregado.
</dd>
<dt>opções_módulo</dt>
<dd>
Opções que serão usadas pelo módulo.  Variam de módulo para módulo, alguns
precisam de opções outros não, tente primeiro carregar sem opções, caso seja
mostrada uma mensagem de erro verifique as opções usadas por ele.  Para
detalhes sobre que opções são suportadas por cada módulo, veja a sua
documentação no código fonte do kernel em
<code>/usr/src/linux/Documentation</code>
</dd>
</dl>

<p>
Nem todos os módulos são carregados corretamente pelo <code>modprobe</code>, o
<code>plip</code>, por exemplo, mostra uma mensagem sobre porta I/O inválida
mas não caso seja carregado pelo <code>insmod</code>.

<p>
Exemplo: <samp>modprobe ne io=0x300 irq=10</samp>, <samp>modprobe sb io=0x220
irq=5 dma=1 dma16=5 mpuio=0x330</samp>

<hr>

<a name="s-kern-depmod"></a>
<h2>16.9 depmod</h2>

<p>
Verifica a dependência de módulos.  As dependências dos módulos são verificadas
pelos scripts em <code>/etc/init.d</code> usando o comando <samp>depmod
-a</samp> e o resultado gravado no arquivo
<code>/lib/modules/versao_do_kernel/modules.dep</code>.  Esta checagem serve
para que todas as dependências de módulos estejam corretamente disponíveis na
inicialização do sistema.  O comportamento do <code>depmod</code> pode ser
modificado através do arquivo <code>/etc/modules.conf</code> .  É possível
criar a dependência de módulos imediatamente após a compilação do kernel
digitando <samp>depmod -a [<em>versão_do_kernel</em>]</samp>.

<p>
Exemplo: <samp>depmod -a</samp>

<hr>

<a name="s-kern-modconf"></a>
<h2>16.10 modconf</h2>

<p>
Este programa permite um meio mais fácil de configurar a ativação de módulos e
opções através de uma interface através de menus.  Selecione a categoria de
módulos através das setas acima e abaixo e pressione enter para selecionar os
módulos existentes.  Serão pedidas as opções do módulo (como DMA, IRQ, I/O)
para que sua inicialização seja possível, estes parâmetros são específicos de
cada módulo e devem ser vistos na documentação do código fonte do kernel no
diretório <code>/usr/src/linux/Documentation</code>.  Note que também existem
módulos com auto-detecção mas isto deixa o sistema um pouco mais lento, porque
ele fará uma varredura na faixa de endereços especificados pelo módulo para
achar o dispositivo.  As opções são desnecessárias em alguns tipos de módulos.

<p>
As modificações feitas por este programa são gravadas no diretório
<code>/etc/modutils</code> em arquivos separados como
<code>/etc/modutils/alias</code> - alias de módulos,
<code>/etc/modutils/modconf</code> - opções usadas por módulos,
<code>/etc/modutils/paths</code> - Caminho onde os módulos do sistema são
encontrados.  Dentro de <code>/etc/modutils</code> é ainda encontrado um
sub-diretório chamado <code>arch</code> que contém opções específicas por
arquiteturas.

<p>
A sincronização dos arquivos gerados pelo <code>modconf</code> com o
<code>/etc/modules.conf</code> é feita através do utilitário
<code>update-modules</code>.  Ele é normalmente executado após modificações nos
módulos feitas pelo <code>modconf</code>.

<hr>

<a name="s-kern-recompilando"></a>
<h2>16.11 Recompilando o Kernel</h2>

<p>
Será que vou precisar recompilar o meu kernel?  você deve estar se perguntando
agora.  Abaixo alguns motivos para esclarecer suas dúvidas:
<ul>
<li>
Melhora o desempenho do kernel.  O kernel padrão que acompanha as distribuições
<code>GNU/Linux</code> foi feito para funcionar em qualquer tipo de sistema e
garantir seu funcionamento e inclui suporte a praticamente tudo.  Isto pode
gerar desde instabilidade até uma grade pausa do kernel na inicialização quando
estiver procurando pelos dispositivos que simplesmente não existem em seu
computador!

<p>
A compilação permite escolher somente o suporte aos dispositivos existentes em
seu computador e assim diminuir o tamanho do kernel, desocupar a memória RAM
com dispositivos que nunca usará e assim você terá um desempenho bem melhor do
que teria com um kernel pesado.
</li>
</ul>
<ul>
<li>
Incluir suporte a alguns hardwares que estão desativados no kernel padrão (SMP,
APM, Firewall, drivers experimentais, etc).
</li>
</ul>
<ul>
<li>
Se aventurar em compilar um kernel (sistema operacional) personalizado em seu
sistema.
</li>
</ul>
<ul>
<li>
Impressionar os seus amigos, tentando coisas novas.
</li>
</ul>

<p>
Serão necessários uns 70Mb de espaço em disco disponível para copiar e
descompactar o código fonte do kernel e alguns pacotes de desenvolvimento como
o <code>gcc</code>, <code>cpp</code>, <code>binutils</code>,
<code>gcc-i386-gnu</code>, <code>bin86</code>, <code>make</code>,
<code>dpkg-dev</code>, <code>perl</code>, <code>kernel-package</code> (os três
últimos somente para a distribuição <code>Debian</code>).

<p>
Na distribuição <code>Debian</code>, o melhor método é através do
<code>kernel-package</code> que faz tudo para você (menos escolher o que terá o
não o suporte no kernel) e gera um pacote <code>.deb</code> que poderá ser
usado para instalar o kernel em seu sistema ou em qualquer outro que execute a
<code>Debian</code> ou distribuições baseadas (<code>Corel Linux</code>,
<code>Libranet</code>, etc).  Devido a sua facilidade, a compilação do kernel
através do <code>kernel-package</code> é muito recomendado para usuários
iniciantes e para aqueles que usam somente um kernel no sistema (é possível
usar mais de dois ao mesmo tempo, veja o processo de compilação manual adiante
neste capítulo).  Siga este passos para recompilar seu kernel através do
<code>kernel-package</code>:
<ol type="1" start="1" >
<li>
Descompacte o código fonte do kernel (através do arquivo linux-2.2.XX) para o
diretório <code>/usr/src</code>.  Caso use os pacotes da <code>Debian</code>
eles terão o nome de <code>kernel-source-2.2.XX</code>, para detalhes de como
instalar um pacote, veja <a href="ch-dpkg.htm#s-dpkg-instalar">Instalar
pacotes, Seção 20.1.2</a>.
</li>
</ol>
<ol type="1" start="2" >
<li>
Após isto, entre no diretório onde o código fonte do kernel foi instalado com
<samp>cd /usr/src/linux</samp> (este será assumido o lugar onde o código fonte
do kernel se encontra).
</li>
</ol>
<ol type="1" start="3" >
<li>
Como usuário <samp>root</samp>, digite <samp>make config</samp>.  Você também
pode usar <samp>make menuconfig</samp> (configuração através de menus) ou
<samp>make xconfig</samp> (configuração em modo gráfico) mas precisará de
pacotes adicionais para que estes dois funcionem corretamente.

<p>
Serão feitas perguntas sobre se deseja suporte a tal dispositivo, etc.
Pressione <samp>Y</samp> para incluir o suporte diretamente no kernel,
<samp>M</samp> para incluir o suporte como módulo ou <samp>N</samp> para não
incluir o suporte.  Note que nem todos os drivers podem ser compilados como
módulos.

<p>
Escolha as opções que se encaixam em seu sistema.  se estiver em dúvida sobre a
pergunta digite <samp>?</samp> e tecle Enter para ter uma explicação sobre o
que aquela opção faz.  Se não souber do que se trata, recomendo incluir a opção
(pressionando <samp>Y</samp> ou <samp>M</samp>.  Este passo pode levar entre 5
minutos e 1 Hora (usuários que estão fazendo isto pela primeira vez tendem a
levar mais tempo lendo e conhecendo os recursos que o <code>GNU/Linux</code>
possui, antes de tomar qualquer decisão).  Não se preocupe se esquecer de
incluir o suporte a alguma coisa, você pode repetir o passo <samp>make
config</samp> (todas as suas escolhas são gravadas no arquivo
<code>.config</code>), recompilar o kernel e instalar em cima do antigo a
qualquer hora que quiser.
</li>
</ol>
<ol type="1" start="4" >
<li>
Após o <samp>make config</samp> chegar ao final, digite <samp>make-kpkg
clean</samp> para limpar construções anteriores do kernel.
</li>
</ol>
<ol type="1" start="5" >
<li>
Agora compile o kernel digitando <samp>make-kpkg --revision=teste.1.0
kernel-image</samp>.  A palavra <samp>teste</samp> pode ser substituída por
qualquer outra que você quiser e número da versão <samp>1.0</samp> serve apenas
como controle de suas compilações (pode ser qualquer número).

<p>
Observação: Não inclua hífens (<samp>-</samp>) no parâmetro --revision, use
somente pontos.
</li>
</ol>
<ol type="1" start="6" >
<li>
Agora após compilar, o kernel será gravado no diretório superior (..) com um
nome do tipo <samp>kernel-image-2.2.10-i386_teste.1.0.deb</samp>.  Basta você
digitar <samp>dpkg -i kernel-image-2.2.10-i386_teste.1.0.deb</samp> e o
<code>dpkg</code> fará o resto da instalação do kernel para você e perguntará
se deseja criar um disquete de inicialização (recomendável).
</li>
</ol>
<ol type="1" start="7" >
<li>
Reinicie seu computador, seu novo kernel iniciará e você já perceberá a
primeira diferença pela velocidade que o <code>GNU/Linux</code> é iniciado
(você inclui somente suporte a dispositivos em seu sistema).  O desempenho dos
programas também melhorará pois cortou o suporte a dispositivos/funções que seu
computador não precisa.

<p>
Caso alguma coisa sair errada, coloque o disquete que gravou no passo anterior
e reinicie o computador para fazer as correções.
</li>
</ol>

<p>
Para recompilar o kernel usando o método padrão, siga os seguintes passos:
<ol type="1" start="1" >
<li>
Descompacte o código fonte do kernel (através do arquivo linux-2.2.XX) para o
diretório <code>/usr/src</code>.  O código fonte do kernel pode ser encontrado
em <code><a href="ftp://ftp.kernel.org/">ftp://ftp.kernel.org/</a></code>.
</li>
<li>
Após isto, entre no diretório onde o código fonte do kernel foi instalado com
<samp>cd /usr/src/linux</samp> (este será assumido o lugar onde o código fonte
do kernel se encontra).
</li>
<li>
Como usuário <samp>root</samp>, digite <samp>make config</samp>.  Você também
pode usar <samp>make menuconfig</samp> (configuração através de menus) ou
<samp>make xconfig</samp> (configuração em modo gráfico) mas precisará de
pacotes adicionais.
<p>
Serão feitas perguntas sobre se deseja suporte a tal dispositivo, etc.
Pressione <samp>Y</samp> para incluir o suporte diretamente no kernel,
<samp>M</samp> para incluir o suporte como módulo ou <samp>N</samp> para não
incluir o suporte.  Note que nem todos os drivers podem ser compilados como
módulos.
<p>
Escolha as opções que se encaixam em seu sistema.  se estiver em dúvida sobre a
pergunta digite <samp>?</samp> e tecle Enter para ter uma explicação sobre o
que aquela opção faz.  Se não souber do que se trata, recomendo incluir a opção
(pressionando <samp>Y</samp> ou <samp>M</samp>.  Este passo pode levar entre 5
minutos e 1 Hora (usuários que estão fazendo isto pela primeira vez tendem a
levar mais tempo lendo e conhecendo os recursos que o <code>GNU/Linux</code>
possui antes de tomar qualquer decisão).  Não se preocupe se esquecer de
incluir o suporte a alguma coisa, você pode repetir o passo <samp>make
config</samp>, recompilar o kernel e instalar em cima do antigo a qualquer hora
que quiser.
</li>
<li>
Digite o comando <samp>make dep</samp> para verificar as dependências dos
módulos.
</li>
<li>
Digite o comando <samp>make clean</samp> para limpar construções anteriores do
kernel.
</li>
<li>
Digite o comando <samp>make zImage</samp> para iniciar a compilação do kernel
estático (outro comando compila os módulos).  Aguarde a compilação, o tempo
pode variar dependendo da quantidade de recursos que adicionou ao kernel, a
velocidade de seu computador e a quantidade de memória RAM disponível.
<p>
Caso tenha acrescentado muitos ítens no Kernel, é possível que o comando
<samp>make zImage</samp> falhe no final (especialmente se o tamanho do kernel
estático for maior que 505Kb).  Neste caso use <samp>make bzImage</samp>.  A
diferença entre <em>zImage</em> e <em>bzImage</em> é que o primeiro possui um
limite de tamanho porque é descompactado na memória básica (recomendado para
alguns Notebooks), já a <em>bzImage</em>, é descompactada na memória estendida
e não possui as limitações da <em>zImage</em>.
</li>
<li>
Após terminada a compilação do kernel estático, execute <samp>make
modules</samp> para compilar os módulos referentes àquele kernel.  A velocidade
de compilação pode variar de acordo com os motivos do passo anterior.
</li>
<li>
A compilação neste ponto está completa, você agora tem duas opções para
instalar o kernel: Substituir o kernel anterior pelo recém compilado ou usar os
dois.  A segunda questão é recomendável se você não tem certeza se o kernel
funcionará corretamente e deseja iniciar pelo antigo no caso de alguma coisa
dar errado.
<p>
Se você optar por substituir o kernel anterior:
<ol type="1" start="1" >
<li>
É recomendável renomear o diretório <code>/lib/modules/versão_do_kernel</code>
para <code>/lib/modules/versão_do_kernel.old</code>, isto será útil para
restauração completa dos módulos antigos caso alguma coisa der errado.
</li>
<li>
Execute o comando <samp>make modules_install</samp> para instalar os módulos do
kernel recém compilado em <code>/lib/modules/versão_do_kernel</code>.
</li>
<li>
Copie o arquivo <code>zImage</code> que contém o kernel de
<code>/usr/src/linux/arch/i386/boot/zImage</code> para
<code>/boot/vmlinuz-2.XX.XX</code> (<em>2.XX.XX</em> é a versão do kernel
anterior)
</li>
<li>
Verifique se o link simbólico <code>/vmlinuz</code> aponta para a versão do
kernel que compilou atualmente (com <samp>ls -la /</samp>).  Caso contrário,
apague o arquivo <code>/vmlinuz</code> do diretório raíz e crie um novo link
com <samp>ln -s /boot/vmlinuz-2.XX.Xx /vmlinuz</samp> apontando para o kernel
correto.
</li>
<li>
Execute o comando <samp>lilo</samp> para gerar um novo setor de partida no
disco rígido.  Para detalhes veja <a href="ch-boot.htm#s-boot-lilo">LILO, Seção
6.1</a>.
</li>
<li>
Reinicie o sistema (<samp>shutdown -r now</samp>).
</li>
<li>
Caso tudo esteja funcionando normalmente, apague o diretório antigo de módulos
que salvou e o kernel antigo de <code>/boot</code>.  Caso algo tenha dado
errado e seu sistema não inicializa, inicie a partir de um disquete, apague o
novo kernel, apague os novos módulos, renomeie o diretório de módulos antigos
para o nome original, ajuste o link simbólico <code>/vmlinuz</code> para
apontar para o antigo kernel e execute o <samp>lilo</samp>.  Após reiniciar seu
computador voltará como estava antes.
</li>
</ol>
<p>
Se você optar por manter o kernel anterior e selecionar qual será usado na
partida do sistema (útil para um kernel em testes):
<ol type="1" start="1" >
<li>
Execute o comando <samp>make modules_install</samp> para instalar os módulos
recém compilados do kernel em <code>/lib/modules/versao_do_kernel</code>.
</li>
<li>
Copie o arquivo <code>zImage</code> que contém o kernel de
<code>/usr/src/linux/arch/i386/boot/zImage</code> para
<code>/boot/vmlinuz-2.XX.XX</code> (<em>2.XX.XX</em> é a versão do kernel
anterior)
</li>
<li>
Crie um link simbólico no diretório raíz (<code>/</code>) apontando para o novo
kernel.  Como exemplos será usado <code>/vmlinuz-novo</code>.
</li>
<li>
Modifique o arquivo <code>/etc/lilo.conf</code> para incluir a nova imagem de
kernel.  Por exemplo:
<pre>
     Antes da modificação:
     
     boot=/dev/hda
     prompt
     timeout=200
     delay=200
     map=/boot/map
     install=menu
     
     image = /vmlinuz
       root = /dev/hda1
       label = 1
       read-only
     
     Depois da modificação:
     
     boot=/dev/hda
     prompt
     timeout=200
     delay=200
     map=/boot/map
     install=menu
     
     image = /vmlinuz
       root = /dev/hda1
       label = 1
       read-only
     
     image = /vmlinuz-new
       root = /dev/hda1
       label = 2
       read-only
</pre>
<p>
Se você digitar <samp>1</samp> no aviso de <samp>boot:</samp> do
<code>Lilo</code>, o kernel antigo será carregado, caso digitar <samp>2</samp>
o novo kernel será carregado.  Para detalhes veja <a
href="ch-boot.htm#s-boot-lilo-cfg">Criando o arquivo de configuração do LILO,
Seção 6.1.1</a> e <a href="ch-boot.htm#s-boot-lilo-exemplo">Um exemplo do
arquivo de configuração lilo.conf, Seção 6.1.3</a>.
</li>
<li>
Execute o comando <samp>lilo</samp> para gravar o novo setor de boot para o
disco rígido.
</li>
<li>
Reinicie o computador
</li>
<li>
Carregue o novo kernel escolhendo a opção <samp>2</samp> no aviso de
<samp>boot:</samp> do <code>Lilo</code>.  Caso tiver problemas, escolha a opção
<samp>1</samp> para iniciar com o kernel antigo e verifique os passos de
configuração (o arquivo <code>lilo.conf</code> foi modificado corretamente?.
</li>
</ol>
</li>
</ol>

<p>
Em alguns casos (como nos kernels empacotados em distribuições
<code>GNU/Linux</code>) o código fonte do kernel é gravado em um diretório
chamado <code>kernel-source-xx.xx.xx</code>.  É recomendável fazer um link com
um diretório <code>GNU/Linux</code>, pois é o padrão usado pelas atualização do
código fonte através de patches (veja <a href="#s-kern-patches">Aplicando
Patches no kernel, Seção 16.13</a>).

<p>
Para criar o link simbólico, entre em <code>/usr/src</code> e digite: <samp>ln
-s kernel-source-xx.xx.xx linux</samp>.

<p>
Se quiser mais detalhes sobre a compilação do kernel, consulte o documento
<em>kernel-howto</em>.

<hr>

<a name="s-kern-arquivos"></a>
<h2>16.12 Arquivos relacionados com o Kernel e Módulos</h2>

<p>
Esta seção descreve os arquivos usados pelo kernel e módulos, a função de cada
um no sistema, a sintaxe, etc.

<hr>

<a name="s-kern-arquivos-modules"></a>
<h3>16.12.1 /etc/modules</h3>

<p>
A função deste arquivo é carregar módulos especificados na inicialização do
sistema e mantê-los carregado todo o tempo.  É útil para módulos de placas de
rede que precisam ser carregados antes da configuração de rede feita pela
distribuição e não podem ser removidos quando a placa de rede estiver sem uso
(isto retiraria seu computador da rede).

<p>
Seu conteúdo é uma lista de módulos (um por linha) que serão carregados na
inicialização do sistema.  Os módulos carregados pelo arquivo
<code>/etc/modules</code> pode ser listados usando o comando <code>lsmod</code>
(veja <a href="#s-kern-lsmod">lsmod, Seção 16.5</a>.

<p>
Se o parâmetro <samp>auto</samp> estiver especificado como um módulo, o
<code>kmod</code> será ativado e carregará os módulos somente em demanda, caso
seja especificado <samp>noauto</samp> o programa <code>kmod</code> será
desativado.  O <code>kmod</code> é ativado por padrão nos níveis de execução 2
ao 5.

<p>
Ele pode ser editado em qualquer editor de textos comum ou modificado
automaticamente através do utilitário <code>modconf</code>.

<hr>

<a name="s-kern-arquivos-modulesconf"></a>
<h3>16.12.2 modules.conf</h3>

<p>
O arquivo <code>/etc/modules.conf</code> permite controlar as opções de todos
os módulos do sistema.  Ele é consultado pelos programas <code>modprobe</code>
e <code>depmod</code>.  As opções especificadas neste arquivo facilita o
gerenciamento de módulos, evitando a digitação de opções através da linha de
comando.

<p>
Note que é recomendado o uso do utilitário <code>modconf</code> para configurar
quaisquer módulos em seu sistema e o utilitário <code>update-modules</code>
para sincronização dos arquivos gerados pelo <code>modconf</code> em
<code>/etc/modutils</code> com o <code>/etc/modules.conf</code> (geralmente
isto é feito automaticamente após o uso do <code>modconf</code>).  Por este
motivo não é recomendável modifica-lo manualmente, a não ser que seja um
usuário experiente e saiba o que está fazendo.  Veja <a
href="#s-kern-modconf">modconf, Seção 16.10</a>

<p>
Por exemplo: adicionando as linhas:

<pre>
     alias sound sb 
     options sb io=0x220 irq=5 dma=1 dma16=5 mpuio=0x330
</pre>

<p>
permitirá que seja usado somente o comando <samp>modprobe sb</samp> para ativar
a placa de som.

<hr>

<a name="s-kern-patches"></a>
<h2>16.13 Aplicando Patches no kernel</h2>

<p>
<em>Patches</em> são modificações geradas pelo programa <code>diff</code> em
que servem para atualizar um programa ou texto.  Este recurso é muito útil para
os desenvolvedores, pois podem gerar um arquivo contendo as diferenças entre um
programa antigo e um novo (usando o comando <code>diff</code>) e enviar o
arquivo contendo as diferenças para outras pessoas.

<p>
As pessoas interessadas em atualizar o programa antigo, podem simplesmente
pegar o arquivo contendo as diferenças e atualizar o programa usando o
<code>patch</code>.

<p>
Isto é muito usado no desenvolvimento do kernel do <code>GNU/Linux</code> em
que novas versões são lançadas freqüentemente e o tamanho kernel completo
compactado ocupa cerca de 18MB.  Você pode atualizar seu kernel pegando um
patch seguinte a versão que possui em <code><a
href="ftp://ftp.kernel.org/">ftp://ftp.kernel.org/</a></code>.

<p>
Para aplicar um patch que atualizará seu kernel 2.2.13 para a versão 2.2.14
você deve proceder da seguinte forma:
<ul>
<li>
Descompacte o código fonte do kernel 2.2.13 em <code>/usr/src/linux</code> ou
certifique-se que existe um link simbólico do código fonte do kernel para
<code>/usr/src/linux</code>.
</li>
<li>
Copie o arquivo <code>patch-2.2.14.gz</code> de <code><a
href="ftp://ftp.kernel.org/">ftp://ftp.kernel.org/</a></code> para
<code>/usr/src</code>.
</li>
<li>
Use o comando <samp>gzip -dc patch-2.2.14|patch -p0 -N -E</samp> para atualizar
o código fonte em <code>/usr/src/linux</code> para a versão 2.2.14.
<p>
Alternativamente você pode primeiro descompactar o arquivo
<code>patch-2.2.14.gz</code> com o <code>gzip</code> e usar o comando
<samp>patch -p0 -N -E &lt;patch-2.2.14</samp> para atualizar o código fonte do
kernel.  O <code>GNU/Linux</code> permite que você obtenha o mesmo resultado
através de diferentes métodos, a escolha é somente sua.
</li>
</ul>

<p>
Caso deseja atualizar o kernel 2.2.10 para 2.2.14, como no exemplo acima, você
deverá aplicar os patches em seqüência (do patch 2.2.11 ao 2.2.14).  Vale a
pena observar se o tamanho total dos patches ultrapassa ou chega perto o
tamanho do kernel completo.

<hr>

[ <a href="ch-rede.htm">anterior</a> ]
[ <a href="index.htm#contents">Conteúdo</a> ]
[ <a href="ch-intro.htm">1</a> ]
[ <a href="ch-bas.htm">2</a> ]
[ <a href="ch-hardw.htm">3</a> ]
[ <a href="ch-d-l.htm">4</a> ]
[ <a href="ch-disc.htm">5</a> ]
[ <a href="ch-boot.htm">6</a> ]
[ <a href="ch-run.htm">7</a> ]
[ <a href="ch-cmdd.htm">8</a> ]
[ <a href="ch-cmd.htm">9</a> ]
[ <a href="ch-cmdv.htm">10</a> ]
[ <a href="ch-cmdn.htm">11</a> ]
[ <a href="ch-cmdc.htm">12</a> ]
[ <a href="ch-perm.htm">13</a> ]
[ <a href="ch-redir.htm">14</a> ]
[ <a href="ch-rede.htm">15</a> ]
[ 16 ]
[ <a href="ch-log.htm">17</a> ]
[ <a href="ch-cpctd.htm">18</a> ]
[ <a href="ch-deb.htm">19</a> ]
[ <a href="ch-dpkg.htm">20</a> ]
[ <a href="ch-pers.htm">21</a> ]
[ <a href="ch-impr.htm">22</a> ]
[ <a href="ch-cfg.htm">23</a> ]
[ <a href="ch-tasks.htm">24</a> ]
[ <a href="ch-compil.htm">25</a> ]
[ <a href="ch-manut.htm">26</a> ]
[ <a href="ch-etc.htm">27</a> ]
[ <a href="ch-inter.htm">28</a> ]
[ <a href="ch-x11.htm">29</a> ]
[ <a href="ch-aplic.htm">30</a> ]
[ <a href="ch-ajuda.htm">31</a> ]
[ <a href="ch-apend.htm">32</a> ]
[ <a href="ch-log.htm">próximo</a> ]

<hr>

<p>
Guia Foca GNU/Linux

<address>
Versão 5.45 - segunda, 30 de outubro de 2006<br>
<br>
Gleydson Mazioli da Silva <code><a href="mailto:gleydson@guiafoca.org">gleydson@guiafoca.org</a></code><br>
<br>
</address>

<hr>

</body>

</html>

