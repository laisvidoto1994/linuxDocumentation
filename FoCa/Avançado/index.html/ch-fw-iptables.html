<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">

<title>Guia Foca GNU/Linux - Firewall iptables</title>

</head>

<body>

<a name="ch-fw-iptables"></a>
<hr>

[ <a href="ch-impr.html">anterior</a> ]
[ <a href="index.html#contents">Conteúdo</a> ]
[ <a href="ch-intro.html">1</a> ]
[ <a href="ch-bas.html">2</a> ]
[ <a href="ch-hardw.html">3</a> ]
[ <a href="ch-rede.html">4</a> ]
[ <a href="ch-cfgrede.html">5</a> ]
[ <a href="ch-log.html">6</a> ]
[ <a href="ch-deb.html">7</a> ]
[ <a href="ch-pers.html">8</a> ]
[ <a href="ch-impr.html">9</a> ]
[ 10 ]
[ <a href="ch-d-contas.html">11</a> ]
[ <a href="ch-s-apache.html">12</a> ]
[ <a href="ch-s-ident.html">13</a> ]
[ <a href="ch-s-telnet.html">14</a> ]
[ <a href="ch-s-ssh.html">15</a> ]
[ <a href="ch-s-pop3.html">16</a> ]
[ <a href="ch-s-cvs.html">17</a> ]
[ <a href="ch-s-samba.html">18</a> ]
[ <a href="ch-d-restr.html">19</a> ]
[ <a href="ch-d-cripto.html">20</a> ]
[ <a href="ch-apend.html">21</a> ]
[ <a href="ch-d-contas.html">próximo</a> ]

<hr>

<h1>
Guia Foca GNU/Linux
<br>Capítulo 10 - Firewall iptables
</h1>

<hr>

<p>
Este capítulo documenta o funcionamento do firewall <code>iptables</code> que
acompanha a série do kernel 2.4, opções usadas, e aponta alguns pontos
fundamentais para iniciar a configuração e construção de bons sistemas de
firewall.

<hr>

<a name="s-fw-iptables-intro"></a>
<h2>10.1 Introdução</h2>

<p>
O <em>Firewall</em> é um programa que como objetivo proteger a máquina contra
acessos indesejados, tráfego indesejado, proteger serviços que estejam rodando
na máquina e bloquear a passagem de coisas que você não deseja receber (como
conexões vindas da Internet para sua segura rede local, evitando acesso aos
dados corporativos de uma empresa ou a seus dados pessoais).  No kernel do
Linux 2.4, foi introduzido o firewall <code>iptables</code> (também chamado de
netfilter) que substitui o <code>ipchains</code> dos kernels da série 2.2.
Este novo firewall tem como vantagem ser muito estável (assim como o
<code>ipchains</code> e <code>ipfwadm</code>), confiável, permitir muita
flexibilidade na programação de regras pelo administrador do sistema, mais
opções disponíveis ao administrador para controle de tráfego, controle
independente do tráfego da rede local/entre redes/interfaces devido a nova
organização das etapas de roteamento de pacotes.

<p>
O <code>iptables</code> é um firewall em nível de pacotes e funciona baseado no
endereço/porta de origem/destino do pacote, prioridade, etc.  Ele funciona
através da comparação de regras para saber se um pacote tem ou não permissão
para passar.  Em firewalls mais restritivos, o pacote é bloqueado e registrado
para que o administrador do sistema tenha conhecimento sobre o que está
acontecendo em seu sistema.

<p>
Ele também pode ser usado para modificar e monitorar o tráfego da rede, fazer
NAT (masquerading, source nat, destination nat), redirecionamento de pacotes,
marcação de pacotes, modificar a prioridade de pacotes que chegam/saem do seu
sistema, contagem de bytes, dividir tráfego entre máquinas, criar proteções
anti-spoofing, contra syn flood, DoS, etc.  O tráfego vindo de máquinas
desconhecidas da rede pode também ser bloqueado/registrado através do uso de
simples regras.  As possibilidades oferecidas pelos recursos de filtragem
<code>iptables</code> como todas as ferramentas UNIX maduras dependem de sua
imaginação, pois ele garante uma grande flexibilidade na manipulação das regras
de acesso ao sistema, precisando apenas conhecer quais interfaces o sistema
possui, o que deseja bloquear, o que tem acesso garantido, quais serviços devem
estar acessíveis para cada rede, e iniciar a construção de seu firewall.

<p>
O <code>iptables</code> ainda tem a vantagem de ser modularizável, funções
podem ser adicionadas ao firewall ampliando as possibilidades oferecidas.  Usei
por 2 anos o <code>ipchains</code> e afirmo que este é um firewall que tem
possibilidades de gerenciar tanto a segurança em máquinas isoladas como
roteamento em grandes organizações, onde a passagem de tráfego entre redes deve
ser minuciosamente controlada.

<p>
Um firewall não funciona de forma automática (instalando e esperar que ele faça
as coisas por você), é necessário pelo menos conhecimentos básicos de rede
tcp/ip, roteamento e portas para criar as regras que farão a segurança de seu
sistema.  A segurança do sistema depende do controle das regras que serão
criadas por você, as falhas humanas são garantia de mais de 95% de sucesso nas
invasões.

<p>
Enfim o <code>iptables</code> é um firewall que agradará tanto a pessoas que
desejam uma segurança básica em seu sistema, quando administradores de grandes
redes que querem ter um controle minucioso sobre o tráfego que passam entre
suas interfaces de rede (controlando tudo o que pode passar de uma rede a
outra), controlar o uso de tráfego, monitoração, etc.

<hr>

<a name="s-fw-iptables-versao"></a>
<h3>10.1.1 Versão</h3>

<p>
É assumido que esteja usando a versão 1.2.3 do <code>iptables</code> e baseadas
nas opções do kernel 2.4.16 (sem o uso de módulos experimentais).  As
explicações contidas aqui podem funcionar para versões posteriores, mas é
recomendável que leia a documentação sobre modificações no programa (changelog)
em busca de mudanças que alterem o sentido das explicações fornecidas aqui.

<hr>

<a name="s-fw-iptables-historia"></a>
<h3>10.1.2 Um resumo da história do iptables</h3>

<p>
O <code>iptables</code> é um código de firewall das versões 2.4 do kernel, que
substituiu o <code>ipchains</code> (presente nas séries 2.2 do kernel).  Ele
foi incluído no kernel da série 2.4 em meados de Junho/Julho de 1999.

<p>
A história do desenvolvimento (desde o porte do <code>ipfw</code> do
<code>BSD</code> para o <code>Linux</code> até o <code>iptables</code> (que é a
quarta geração de firewalls do kernel) está disponível no documento,
<samp>Netfilter-howto</samp>.

<hr>

<a name="s-fw-iptables-caracteristicas"></a>
<h3>10.1.3 Características do firewall iptables</h3>

<ul>
<li>
Especificação de portas/endereço de origem/destino
</li>
<li>
Suporte a protocolos TCP/UDP/ICMP (incluindo tipos de mensagens icmp)
</li>
<li>
Suporte a interfaces de origem/destino de pacotes
</li>
<li>
Manipula serviços de proxy na rede
</li>
<li>
Tratamento de tráfego dividido em chains (para melhor controle do tráfego que
entra/sai da máquina e tráfego redirecionado.
</li>
<li>
Permite um número ilimitado de regras por chain
</li>
<li>
Muito rápido, estável e seguro
</li>
<li>
Possui mecanismos internos para rejeitar automaticamente pacotes duvidosos ou
mal formados.
</li>
<li>
Suporte a módulos externos para expansão das funcionalidades padrões oferecidas
pelo código de firewall
</li>
<li>
Suporte completo a roteamento de pacotes, tratadas em uma área diferente de
tráfegos padrões.
</li>
<li>
Suporte a especificação de tipo de serviço para priorizar o tráfego de
determinados tipos de pacotes.
</li>
<li>
Permite especificar exceções para as regras ou parte das regras
</li>
<li>
Suporte a detecção de fragmentos
</li>
<li>
Permite enviar alertas personalizados ao <code>syslog</code> sobre o tráfego
aceito/bloqueado.
</li>
<li>
Redirecionamento de portas
</li>
<li>
Masquerading
</li>
<li>
Suporte a SNAT (modificação do endereço de origem das máquinas para um único IP
ou faixa de IP's).
</li>
<li>
Suporte a DNAT (modificação do endereço de destino das máquinas para um único
IP ou fixa de IP's)
</li>
<li>
Contagem de pacotes que atravessaram uma interface/regra
</li>
<li>
Limitação de passagem de pacotes/conferência de regra (muito útil para criar
proteções contra, syn flood, ping flood, DoS, etc).
</li>
</ul>

<hr>

<a name="s-fw-iptables-ficha"></a>
<h3>10.1.4 Ficha técnica</h3>

<p>
Pacote: <code>iptables</code>

<ul>
<li>
<samp>iptables</samp> - Sistema de controle principal para protocolos ipv4
</li>
<li>
<samp>ip6tables</samp> - Sistema de controle principal para protocolos ipv6
</li>
<li>
<samp>iptables-save</samp> - Salva as regras atuais em um arquivo especificado
como argumento.  Este utilitário pode ser dispensado por um shell script
contendo as regras executado na inicialização da máquina.
</li>
<li>
<samp>iptables-restore</samp> - Restaura regras salvas pelo utilitário
<code>iptables-save</code>.
</li>
</ul>

<hr>

<a name="s-fw-iptables-hwreq"></a>
<h3>10.1.5 Requerimentos</h3>

<p>
É necessário que o seu kernel tenha sido compilado com suporte ao
<code>iptables</code> (veja <a href="#s-fw-iptables-supkernel">Habilitando o
suporte ao iptables no kernel, Seção 10.1.15</a>.  O requerimento mínimo de
memória necessária para a execução do <code>iptables</code> é o mesmo do kernel
2.4 (4MB).  Dependendo do tráfego que será manipulado pela(s) interface(s) do
firewall ele poderá ser executado com folga em uma máquina 386 SX com 4MB de
RAM.

<p>
Como as configurações residem no kernel não é necessário espaço extra em disco
rígido para a execução deste utilitário.

<hr>

<a name="s-fw-iptables-logs"></a>
<h3>10.1.6 Arquivos de logs criados pelo iptables</h3>

<p>
Todo tráfego que for registrado pelo <code>iptables</code> é registrado por
padrão no arquivo <code>/var/log/kern.log</code>.

<hr>

<a name="s-fw-iptables-install"></a>
<h3>10.1.7 Instalação</h3>

<p>
<samp>apt-get install iptables</samp>

<p>
O pacote <code>iptables</code> contém o utilitário <code>iptables</code> (e
<code>ip6tables</code> para redes ipv6) necessários para inserir suas regras no
kernel.  Se você não sabe o que é ipv6, não precisará se preocupar com o
utilitário <code>ip6tables</code> por enquanto.

<hr>

<a name="s-fw-iptables-contribuindo"></a>
<h3>10.1.8 Enviando Correções/Contribuindo com o projeto</h3>

<p>
A página principal do projeto é <samp><code><a
href="http://netfilter.filewatcher.org">http://netfilter.filewatcher.org</a></code></samp>.
Sugestões podem ser enviadas para a lista de desenvolvimento oficial do
<code>iptables</code>: <samp><code><a
href="http://lists.samba.org">http://lists.samba.org</a></code></samp>.

<hr>

<a name="s-fw-iptables-oldfw"></a>
<h3>10.1.9 O que aconteceu com o <code>ipchains</code> e <code>ipfwadm</code>?</h3>

<p>
O <code>iptables</code> faz parte da nova geração de firewalls que acompanha o
kernel 2.4, mas o suporte ao <code>ipchains</code> e <code>ipfwadm</code> ainda
será mantido através de módulos de compatibilidade do kernel até 2004.  Seria
uma grande falta de consideração retirar o suporte a estes firewalls do kernel
como forma de obrigar a &quot;aprenderem&quot; o <code>iptables</code> (mesmo o
suporte sendo removido após este período, acredito que criarão patches
&quot;externos&quot; para futuros kernels que não trarão mais este suporte).
Se precisa do suporte a estes firewalls antes de passar em definitivo para o
<code>iptables</code> leia <a href="#s-fw-iptables-supkernel">Habilitando o
suporte ao iptables no kernel, Seção 10.1.15</a>.

<p>
Se você é um administrador que gosta de explorar todos os recursos de um
firewall, usa todos os recursos que ele oferece ou mantém uma complexa rede
corporativa, tenho certeza que gostará do <code>iptables</code>.

<hr>

<a name="s-fw-iptables-tiposfw"></a>
<h3>10.1.10 Tipos de firewalls</h3>

<p>
Existem basicamente dois tipos de firewalls:
<ul>
<li>
<samp>nível de aplicação</samp> - Este tipo de firewall analisam o conteúdo do
pacote para tomar suas decisões de filtragem.  Firewalls deste tipo são mais
intrusivos (pois analisam o conteúdo de tudo que passa por ele) e permitem um
controle relacionado com o conteúdo do tráfego.  Alguns firewalls em nível de
aplicação combinam recursos básicos existentes em firewalls em nível de pacotes
combinando as funcionalidade de controle de tráfego/controle de acesso em uma
só ferramenta.  Servidores proxy, como o <code>squid</code>, são um exemplo
deste tipo de firewall.
</li>
<li>
<samp>nível de pacotes</samp> - Este tipo de firewall toma as decisões baseadas
nos parâmetros do pacote, como porta/endereço de origem/destino, estado da
conexão, e outros parâmetros do pacote.  O firewall então pode negar o pacote
(DROP) ou deixar o pacote passar (ACCEPT).  O <code>iptables</code> é um
excelente firewall que se encaixa nesta categoria.
<p>
Firewall em nível de pacotes é o assunto explicado nesta seção do guia mas será
apresentada uma explicação breve sobre o funcionamento de análise de strings do
<code>iptables</code>.
</li>
</ul>

<p>
Os dois tipos de firewalls podem ser usados em conjunto para fornecer uma
camada dupla de segurança no acesso as suas máquinas/máquinas clientes.

<hr>

<a name="s-fw-iptables-proteger-oque"></a>
<h3>10.1.11 O que proteger?</h3>

<p>
Antes de iniciar a construção do firewall é bom pensar nos seguintes pontos:
<ul>
<li>
Quais serviços precisa proteger.  Serviços que devem ter acesso garantido a
usuários externos e quais serão bloqueados a todas/determinadas máquinas.  É
recomendável bloquear o acesso a todas portas menores que 1024 por executarem
serviços que rodam com privilégio de usuário <samp>root</samp>, e autorizar
somente o acesso as portas que realmente deseja (configuração restritiva nesta
faixa de portas).
</li>
<li>
Que tipo de conexões eu posso deixar passar e quais bloquear.  Serviços com
autenticação em texto plano e potencialmente inseguros como rlogin, telnet,
ftp, NFS, DNS, LDAP, SMTP RCP, X-Window são serviços que devem ser ter acesso
garantido somente para máquinas/redes que você confia.  Estes serviços podem
não ser só usados para tentativa de acesso ao seu sistema, mas também como
forma de atacar outras pessoas aproveitando-se de problemas de configuração.
<p>
A configuração do firewall ajuda a prevenir isso, mesmo se um serviço estiver
mal configurado e tentando enviar seus pacotes para fora, será impedido.  Da
mesma forma se uma máquina Windows de sua rede for infectada por um trojan não
haverá pânico: o firewall poderá estar configurado para bloquear qualquer
tentativa de conexão vinda da internet (cracker) para as máquinas de sua rede.
<p>
Para cópia de arquivos via rede insegura (como através da Internet), é
recomendado o uso de serviços que utilizam criptografia para login e
transferência de arquivos (veja <a href="ch-s-ssh.html">Servidor ssh, Capítulo
15</a>) ou a configuração de uma VPN.
</li>
<li>
Que máquinas terão acesso livre e quais serão restritas.
</li>
<li>
Que serviços deverão ter prioridade no processamento.
</li>
<li>
Que máquinas/redes NUNCA deverão ter acesso a certas/todas máquinas.
</li>
<li>
O volume de tráfego que o servidor manipulará.  Através disso você pode ter que
balancear o tráfego entre outras máquinas, configurar proteções contra DoS, syn
flood, etc.
</li>
<li>
O que tem permissão de passar de uma rede para outra (em máquinas que atuam
como roteadores/gateways de uma rede interna).
</li>
<li>
Etc.
</li>
</ul>

<p>
A análise destes pontos pode determinar a complexidade do firewall, custos de
implementação, prazo de desenvolvimento e tempo de maturidade do código para
implementação.  Existem muitos outros pontos que podem entrar na questão de
desenvolvimento de um sistema de firewall, eles dependem do tipo de firewall
que está desenvolvendo e das políticas de segurança de sua rede.

<hr>

<a name="s-fw-iptables-regras-oque"></a>
<h3>10.1.12 O que são regras?</h3>

<p>
As regras são como comandos passados ao <code>iptables</code> para que ele
realize uma determinada ação (como bloquear ou deixar passar um pacote) de
acordo com o endereço/porta de origem/destino, interface de origem/destino,
etc.  As regras são armazenadas dentro dos chains e processadas na ordem que
são inseridas.

<p>
As regras são armazenadas no kernel, o que significa que quando o computador
for reiniciado tudo o que fez será perdido.  Por este motivo elas deverão ser
gravadas em um arquivo para serem carregadas a cada inicialização.

<p>
Um exemplo de regra: <samp>iptables -A INPUT -s 123.123.123.1 -j DROP</samp>.

<hr>

<a name="s-fw-iptables-chains-oque"></a>
<h3>10.1.13 O que são chains?</h3>

<p>
Os <em>Chains</em> são locais onde as regras do firewall definidas pelo usuário
são armazenadas para operação do firewall.  Existem dois tipos de chains: os
embutidos (como os chains <em>INPUT</em>, <em>OUTPUT</em> e <em>FORWARD</em>) e
os criados pelo usuário.  Os nomes dos chains embutidos devem ser especificados
sempre em maiúsculas (note que os nomes dos chains são case-sensitive, ou seja,
o chain <samp>input</samp> é completamente diferente de <samp>INPUT</samp>).

<hr>

<a name="s-fw-iptables-tabelas"></a>
<h3>10.1.14 O que são tabelas?</h3>

<p>
Tabelas são os locais usados para armazenar os chains e conjunto de regras com
uma determinada característica em comum.  As tabelas podem ser referenciadas
com a opção <em>-t tabela</em> e existem 3 tabelas disponíveis no
<code>iptables</code>:
<ul>
<li>
<samp>filter</samp> - Esta é a tabela padrão, contém 3 chains padrões:
<ul>
<li>
<samp>INPUT</samp> - Consultado para dados que chegam a máquina
</li>
<li>
<samp>OUTPUT</samp> - Consultado para dados que saem da máquina
</li>
<li>
<samp>FORWARD</samp> - Consultado para dados que são redirecionados para outra
interface de rede ou outra máquina.
</li>
</ul>

<p>
Os chains <em>INPUT</em> e <em>OUTPUT</em> somente são atravessados por
conexões indo/se originando de localhost.

<p>
<strong>OBS</strong>: Para conexões locais, somente os chains <em>INPUT</em> e
<em>OUTPUT</em> são consultados na tabela filter.
</li>
</ul>
<ul>
<li>
<samp>nat</samp> - Usada para dados que gera outra conexão (masquerading,
source nat, destination nat, port forwarding, proxy transparente são alguns
exemplos).  Possui 3 chains padrões:
<ul>
<li>
<samp>PREROUTING</samp> - Consultado quando os pacotes precisam ser modificados
logo que chegam.  É o chain ideal para realização de DNAT e redirecionamento de
portas (<a href="#s-fw-iptables-nat-dnat">Fazendo DNAT, Seção 10.4.4</a>).
</li>
<li>
<samp>OUTPUT</samp> - Consultado quando os pacotes gerados localmente precisam
ser modificados antes de serem roteados.  Este chain somente é consultado para
conexões que se originam de IPs de interfaces locais.
</li>
<li>
<samp>POSTROUTING</samp> - Consultado quando os pacotes precisam ser
modificados após o tratamento de roteamento.  É o chain ideal para realização
de SNAT e IP Masquerading (<a href="#s-fw-iptables-nat-snat">Fazendo SNAT,
Seção 10.4.3</a>).
</li>
</ul>
</li>
</ul>
<ul>
<li>
<samp>mangle</samp> - Utilizada para alterações especiais de pacotes (como
modificar o tipo de serviço (TOS) ou outros detalhes que serão explicados no
decorrer do capítulo.  Possui 2 chains padrões:
<ul>
<li>
<samp>INPUT</samp> - Consultado quando os pacotes precisam ser modificados
antes de serem enviados para o chain <em>INPUT</em> da tabela <em>filter</em>.
</li>
<li>
<samp>FORWARD</samp> - Consultado quando os pacotes precisam ser modificados
antes de serem enviados para o chain <em>FORWARD</em> da tabela
<em>filter</em>.
</li>
<li>
<samp>PREROUTING</samp> - Consultado quando os pacotes precisam ser modificados
antes de ser enviados para o chain <em>PREROUTING</em> da tabela <em>nat</em>.
</li>
<li>
<samp>POSTROUTING</samp> - Consultado quando os pacotes precisam ser
modificados antes de serem enviados para o chain <em>POSTROUTING</em> da tabela
<em>nat</em>.
</li>
<li>
<samp>OUTPUT</samp> - Consultado quando os pacotes precisam ser modificados
antes de serem enviados para o chain <em>OUTPUT</em> da tabela <em>nat</em>.
</li>
</ul>

<p>
Veja <a href="#s-fw-iptables-mangle">A tabela mangle, Seção 10.5</a> para mais
detalhes sobre a tabela mangle.
</li>
</ul>

<hr>

<a name="s-fw-iptables-supkernel"></a>
<h3>10.1.15 Habilitando o suporte ao iptables no kernel</h3>

<p>
Para usar toda a funcionalidade do firewall <code>iptables</code>, permitindo
fazer o controle do que tem ou não permissão de acessar sua máquina, fazer
Masquerading/NAT em sua rede, etc., você precisará dos seguintes componentes
compilados em seu kernel (os módulos experimentais fora ignorados
intencionalmente):

<pre>
     *
     * Network Options:
     *
     
     Network packet filtering (replaces ipchains) [Y/m/n/?]
      Network packet filtering debugging [Y/m/n/?]
     
     e na Subseção:
     
     *
     *   IP: Netfilter Configuration
     *
     Connection tracking (required for masq/NAT) (CONFIG_IP_NF_CONNTRACK) [M/n/y/?] 
       FTP protocol support (CONFIG_IP_NF_FTP) [M/n/?] 
       IRC protocol support (CONFIG_IP_NF_IRC) [M/n/?]
     IP tables support (required for filtering/masq/NAT) (CONFIG_IP_NF_IPTABLES) [Y/m/n/?]
       limit match support (CONFIG_IP_NF_MATCH_LIMIT) [Y/m/n/?] 
       MAC address match support (CONFIG_IP_NF_MATCH_MAC) [M/n/y/?] 
       netfilter MARK match support (CONFIG_IP_NF_MATCH_MARK) [M/n/y/?] 
       Multiple port match support (CONFIG_IP_NF_MATCH_MULTIPORT) [M/n/y/?] 
       TOS match support (CONFIG_IP_NF_MATCH_TOS) [M/n/y/?] 
       LENGTH match support (CONFIG_IP_NF_MATCH_LENGTH) [M/n/y/?]
       TTL match support (CONFIG_IP_NF_TTL) [M/n/y/?]
       tcpmss match support (CONFIG_IP_NF_MATCH_TCPMSS) [M/n/y/?] 
       Connection state match support (CONFIG_IP_NF_MATCH_STATE) [M/n/?] 
       Packet filtering (CONFIG_IP_NF_FILTER) [M/n/y/?] 
         REJECT target support (CONFIG_IP_NF_TARGET_REJECT) [M/n/?] 
       Full NAT (CONFIG_IP_NF_NAT) [M/n/?] 
         MASQUERADE target support (CONFIG_IP_NF_TARGET_MASQUERADE) [M/n/?] 
         REDIRECT target support (CONFIG_IP_NF_TARGET_REDIRECT) [M/n/?] 
       Packet mangling (CONFIG_IP_NF_MANGLE) [M/n/y/?] 
         TOS target support (CONFIG_IP_NF_TARGET_TOS) [M/n/?] 
         MARK target support (CONFIG_IP_NF_TARGET_MARK) [M/n/?] 
       LOG target support (CONFIG_IP_NF_TARGET_LOG) [M/n/y/?] 
       TCPMSS target support (CONFIG_IP_NF_TARGET_TCPMSS) [M/n/y/?]
</pre>

<p>
Esta configuração permite que você não tenha problemas para iniciar o uso e
configuração do seu firewall iptables, ela ativa os módulos necessários para
utilização de todos os recursos do firewall <code>iptables</code>.  Quando
conhecer a função de cada um dos parâmetros acima (durante o decorrer do
texto), você poderá eliminar muitas das opções desnecessárias para seu estilo
de firewall ou continuar fazendo uso de todas ;-)

<p>
<strong>OBS1:</strong> A configuração acima leva em consideração que você NÃO
executará os códigos antigos de firewall <code>ipfwadm</code> e
<code>ipchains</code>.  Caso deseje utilizar o <code>ipchains</code> ou o
<code>ipfwadm</code>, será preciso responder com &quot;M&quot; a questão
&quot;IP tables support (required for filtering/masq/NAT)
(CONFIG_IP_NF_IPTABLES)&quot;.  Será necessário carregar manualmente o módulo
correspondente ao firewall que deseja utilizar (<samp>modprobe
<code>iptables_filter.o</code></samp> no caso do <code>iptables</code>).

<p>
Não execute mais de um tipo de firewall ao mesmo tempo!!!

<p>
<strong>OBS2:</strong> É recomendável ativar o daemon <code>kmod</code> para
carga automática de módulos, caso contrário será necessário compilar todas as
partes necessárias embutidas no kernel, carregar os módulos necessários
manualmente ou pelo <code>iptables</code> (através da opção
<em>--modprobe=módulo</em>).

<hr>

<a name="s-fw-iptables-proxy"></a>
<h3>10.1.16 Ligando sua rede interna a Internet</h3>

<p>
Se a sua intenção (como da maioria dos usuários) é conectar sua rede interna a
Internet de forma rápida e simples, leia <a
href="#s-fw-iptables-nat-fastmasquerade">Fazendo IP masquerading (para os
apressados), Seção 10.4.2</a> ou <a href="#s-fw-iptables-nat-snat">Fazendo
SNAT, Seção 10.4.3</a>.  Um exemplo prático de configuração de Masquerading
deste tipo é encontrado em <a href="#s-fw-iptables-exemplo-snat">Conectando sua
rede interna a Internet, Seção 10.8.3</a>.

<p>
Após configurar o masquerading, você só precisará especificar o endereço IP da
máquina masquerading (servidor) como <em>Gateway</em> da rede.  No
<code>Windows 9x/NT/2000</code> isto é feito no Painel de
Controle/Rede/Propriedades de Tcp/IP.  No <code>Linux</code> pode ser feito com
<samp>route add default gw IP_do_Servidor</samp>.

<hr>

<a name="s-fw-iptables-chains"></a>
<h2>10.2 Manipulando chains</h2>

<p>
O <code>iptables</code> trabalha com uma tabela de regras que é analisada uma a
uma até que a última seja processada.  Por padrão, se uma regra tiver qualquer
erro, uma mensagem será mostrada e ela descartada.  O pacote não conferirá e a
ação final (se ele vai ser aceito ou rejeitado) dependerá das regras seguintes.

<p>
As opções passadas ao <code>iptables</code> usadas para manipular os chains são
<strong>SEMPRE</strong> em maiúsculas.  As seguintes operações podem ser
realizadas:

<hr>

<a name="s-fw-iptables-chains-A"></a>
<h3>10.2.1 Adicionando regras - A</h3>

<p>
Como exemplo vamos criar uma regra que bloqueia o acesso a nosso própria
máquina (127.0.0.1 - loopback).  Primeiro daremos um ping para verificar seu
funcionamento:

<pre>
     #ping 127.0.0.1
     PING 127.0.0.1 (127.0.0.1): 56 data bytes
     64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=0.6 ms
     64 bytes from 127.0.0.1: icmp_seq=1 ttl=255 time=0.5 ms
     
     --- 127.0.0.1 ping statistics ---
     2 packets transmitted, 2 packets received, 0% packet loss
     round-trip min/avg/max = 0.5/0.5/0.6 ms
</pre>

<p>
Ok, a máquina responde, agora vamos incluir uma regra no chain INPUT (<em>-A
INPUT</em>) que bloqueie (<em>-j DROP</em>) qualquer acesso indo ao endereço
127.0.0.1 (<em>-d 127.0.0.1</em>):

<p>
<samp>iptables -t filter -A INPUT -d 127.0.0.1 -j DROP</samp>

<p>
Agora verificamos um novo ping:

<pre>
     #ping 127.0.0.1
     PING 127.0.0.1 (127.0.0.1): 56 data bytes
     
     --- 127.0.0.1 ping statistics ---
     2 packets transmitted, 0 packets received, 100% packet loss
</pre>

<p>
Desta vez a máquina 127.0.0.1 não respondeu, pois todos os pacotes com o
destino 127.0.0.1 (-d 127.0.0.1) são rejeitados (-j DROP).  A opção <em>-A</em>
é usada para adicionar novas regras no final do chain.  Além de <em>-j
DROP</em> que serve para rejeitar os pacotes, podemos também usar <em>-j
ACCEPT</em> para aceitar pacotes.  A opção <samp>-j</samp> é chamada de
<em>alvo da regra</em> ou somente <em>alvo</em> pois define o destino do pacote
que atravessa a regra (veja <a href="#s-fw-iptables-outras-alvo">Especificando
um alvo, Seção 10.3.6</a>).  Bem vindo a base de um sistema de firewall :-)

<p>
<strong>OBS1:</strong> - O acesso a interface loopback não deve ser de forma
alguma bloqueado, pois muitos aplicativos utilizam soquetes tcp para realizarem
conexões, mesmo que você não possua uma rede interna.

<p>
<strong>OBS2:</strong> - A tabela <em>filter</em> será usada como padrão caso
nenhuma tabela seja especificada através da opção <samp>-t</samp>.

<hr>

<a name="s-fw-iptables-chains-L"></a>
<h3>10.2.2 Listando regras - L</h3>

<p>
A seguinte sintaxe é usada para listar as regras criadas:

<p>
<samp>iptables [<em>-t tabela</em>] -L [<em>chain</em>]
[<em>opções</em>]</samp>

<p>
Onde:
<dl>
<dt><em>tabela</em></dt>
<dd>
É uma das tabelas usadas pelo <code>iptables</code>.  Se a tabela não for
especificada, a tabela <em>filter</em> será usada como padrão.  Veja <a
href="#s-fw-iptables-tabelas">O que são tabelas?, Seção 10.1.14</a> para
detalhes.
</dd>
<dt><em>chain</em></dt>
<dd>
Um dos chains disponíveis na tabela acima (veja <a
href="#s-fw-iptables-tabelas">O que são tabelas?, Seção 10.1.14</a>) ou criado
pelo usuário (<a href="#s-fw-iptables-chains-N">Criando um novo chain - N,
Seção 10.2.6</a>).  Caso o chain não seja especificado, todos os chains da
tabela serão mostrados.
</dd>
<dt><em>opções</em></dt>
<dd>
As seguintes opções podem ser usadas para listar o conteúdo de chains:
<ul>
<li>
<samp>-v</samp> - Exibe mais detalhes sobre as regras criadas nos chains.
</li>
<li>
<samp>-n</samp> - Exibe endereços de máquinas/portas como números ao invés de
tentar a resolução DNS e consulta ao <code>/etc/services</code>.  A resolução
de nomes pode tomar muito tempo dependendo da quantidade de regras que suas
tabelas possuem e velocidade de sua conexão.
</li>
<li>
<samp>-x</samp> - Exibe números exatos ao invés de números redondos.  Também
mostra a faixa de portas de uma regra de firewall.
</li>
<li>
<samp>--line-numbers</samp> - Exibe o número da posição da regra na primeira
coluna da listagem.
</li>
</ul>
</dd>
</dl>

<p>
Para listar a regra criada anteriormente usamos o comando:

<pre>
     #iptables -t filter -L INPUT
     
     Chain INPUT (policy ACCEPT)
     target     prot opt source               destination         
     DROP       all  --  anywhere             localhost
</pre>

<p>
O comando <samp>iptables -L INPUT -n</samp> tem o mesmo efeito, a diferença é
que são mostrados números ao invés de nomes:

<pre>
     #iptables -L INPUT -n
     
     Chain INPUT (policy ACCEPT)
     target     prot opt source               destination
     DROP       all  --  0.0.0.0/0            127.0.0.1
     
     
     #iptables -L INPUT -n --line-numbers
     
     Chain INPUT (policy ACCEPT)
     num target     prot opt source               destination
     1   DROP       all  --  0.0.0.0/0            127.0.0.1
     
     #iptables -L INPUT -n -v
     Chain INPUT (policy ACCEPT 78 packets, 5820 bytes)
      pkts bytes target     prot opt in     out     source               destination
         2   194 DROP       icmp --  *      *       0.0.0.0/0            127.0.0.1
</pre>

<p>
Os campos assim possuem o seguinte significado:
<dl>
<dt>Chain INPUT</dt>
<dd>
Nome do chain listado
</dd>
<dt>(policy ACCEPT 78 packets, 5820 bytes)</dt>
<dd>
Policiamento padrão do chain (veja <a
href="#s-fw-iptables-chains-P">Especificando o policiamento padrão de um chain
- P, Seção 10.2.12</a>).
</dd>
<dt>pkts</dt>
<dd>
Quantidade de pacotes que atravessaram a regra (veja <a
href="#s-fw-iptables-chains-Z">Zerando contador de bytes dos chains - Z, Seção
10.2.11</a>).
</dd>
<dt>bytes</dt>
<dd>
Quantidade de bytes que atravessaram a regra.  Pode ser referenciado com K
(Kilobytes), M (Megabytes), G (Gigabytes).
</dd>
<dt>target</dt>
<dd>
O alvo da regra, o destino do pacote.  Pode ser ACCEPT, DROP ou outro chain.
Veja <a href="#s-fw-iptables-outras-alvo">Especificando um alvo, Seção
10.3.6</a> para detalhes sobre a especificação de um alvo.
</dd>
<dt>prot</dt>
<dd>
Protocolo especificado pela regra.  Pode ser udp, tcp, icmp ou all.  Veja <a
href="#s-fw-iptables-outras-proto">Especificando um protocolo, Seção 10.3.3</a>
para detalhes.
</dd>
<dt>opt</dt>
<dd>
Opções extras passadas a regra.  Normalmente &quot;!&quot; (veja <a
href="#s-fw-iptables-outras-excessoes">Especificando uma exceção, Seção
10.3.5</a>) ou &quot;f&quot; (veja <a
href="#s-fw-iptables-outras-fragmentos">Especificando fragmentos, Seção
10.3.4</a>).
</dd>
<dt>in</dt>
<dd>
Interface de entrada (de onde os dados chegam).  Veja <a
href="#s-fw-iptables-outras-iface">Especificando a interface de origem/destino,
Seção 10.3.2</a>.
</dd>
<dt>out</dt>
<dd>
Interface de saída (para onde os dados vão).  Veja <a
href="#s-fw-iptables-outras-iface">Especificando a interface de origem/destino,
Seção 10.3.2</a>.
</dd>
<dt>source</dt>
<dd>
Endereço de origem.  Veja <a href="#s-fw-iptables-outras-endOD">Especificando
um endereço de origem/destino, Seção 10.3.1</a>.
</dd>
<dt>destination</dt>
<dd>
Endereço de destino.  Veja <a href="#s-fw-iptables-outras-endOD">Especificando
um endereço de origem/destino, Seção 10.3.1</a>.
</dd>
<dt>outras opções</dt>
<dd>
Estas opções normalmente aparecem quando são usadas a opção -x:
<ul>
<li>
<samp>dpt ou dpts</samp> - Especifica a porta ou faixa de portas de destino.
</li>
<li>
<samp>reject-with icmp-port-unreachable</samp> - Significa que foi usado o alvo
REJECT naquela regra (veja <a href="#s-fw-iptables-outras-alvo-REJECT">Alvo
REJECT, Seção 10.3.6.1</a>).
</li>
</ul>
</dd>
</dl>

<hr>

<a name="s-fw-iptables-chains-D"></a>
<h3>10.2.3 Apagando uma regra - D</h3>

<p>
Para apagar um chain, existem duas alternativas:
<ol type="1" start="1" >
<li>
Quando sabemos qual é o número da regra no chain (listado com a opção
<samp>-L</samp>) podemos referenciar o número diretamente.  Por exemplo, para
apagar a regra criada acima:
<p>
<samp>iptables -t filter -D INPUT 1</samp>
<p>
Esta opção não é boa quando temos um firewall complexo com um grande número de
regras por chains, neste caso a segunda opção é a mais apropriada.
</li>
<li>
Usamos a mesma sintaxe para criar a regra no chain, mas trocamos
<samp>-A</samp> por <samp>-D</samp>:
<p>
<samp>iptables -t filter -D INPUT -d 127.0.0.1 -j DROP</samp>
<p>
Então a regra correspondentes no chain INPUT será automaticamente apagada
(confira listando o chain com a opção &quot;-L&quot;).  Caso o chain possua
várias regras semelhantes, somente a primeira será apagada.
<p>
<strong>OBS:</strong> Não é possível apagar os chains defaults do
<code>iptables</code> (<em>INPUT</em>, <em>OUTPUT</em>...).
</li>
</ol>

<hr>

<a name="s-fw-iptables-chains-I"></a>
<h3>10.2.4 Inserindo uma regra - I</h3>

<p>
Precisamos que o tráfego vindo de <code>192.168.1.15</code> não seja rejeitado
pelo nosso firewall.  Não podemos adicionar uma nova regra (-A) pois esta seria
incluída no final do chain e o tráfego seria rejeitado pela primeira regra
(nunca atingindo a segunda).  A solução é inserir a nova regra antes da regra
que bloqueia todo o tráfego ao endereço <code>127.0.0.1</code> na posição 1:

<p>
<samp>iptables -t filter -I INPUT 1 -s 192.168.1.15 -d 127.0.0.1 -j
ACCEPT</samp>

<p>
Após este comando, temos a regra inserida na primeira posição do chain (repare
no número 1 após INPUT) e a antiga regra número 1 passa a ser a número 2.
Desta forma a regra acima será consultada, se a máquina de origem for
192.168.1.15 então o tráfego estará garantido, caso contrário o tráfego com o
destino 127.0.0.1 será bloqueado na regra seguinte.

<hr>

<a name="s-fw-iptables-chains-R"></a>
<h3>10.2.5 Substituindo uma regra - R</h3>

<p>
Após criar nossa regra, percebemos que a nossa intenção era somente bloquear os
pings com o destino <code>127.0.0.1</code> (pacotes ICMP) e não havia
necessidade de bloquear todo o tráfego da máquina.  Existem duas alternativas:
apagar a regra e inserir uma nova no lugar ou modificar diretamente a regra já
criada sem afetar outras regras existentes e mantendo a sua ordem no chain
(isso é muito importante).  Use o seguinte comando:

<p>
<samp>iptables -R INPUT 2 -d 127.0.0.1 -p icmp -j DROP</samp>

<p>
O número <samp>2</samp> é o número da regra que será substituída no chain
INPUT, e deve ser especificado.  O comando acima substituirá a regra 2 do chain
INPUT (-R INPUT 2) bloqueando (-j DROP) qualquer pacote icmp (-p icmp) com o
destino <code>127.0.0.1</code> (-d 127.0.0.1).

<hr>

<a name="s-fw-iptables-chains-N"></a>
<h3>10.2.6 Criando um novo chain - N</h3>

<p>
Em firewalls organizados com um grande número de regras, é interessante criar
chains individuais para organizar regras de um mesmo tipo ou que tenha por
objetivo analisar um tráfego de uma mesma categoria (interface, endereço de
origem, destino, protocolo, etc) pois podem consumir muitas linhas e tornar o
gerenciamento do firewall confuso (e conseqüentemente causar sérios riscos de
segurança).  O tamanho máximo de um nome de chain é de 31 caracteres e podem
conter tanto letras maiúsculas quanto minúsculas.

<p>
<samp>iptables [<em>-t tabela</em>] [<em>-N novochain</em>]</samp>

<p>
Para criar o chain <em>internet</em> (que pode ser usado para agrupar as regras
de internet) usamos o seguinte comando:

<pre>
      iptables -t filter -N internet
</pre>

<p>
Para inserir regras no chain <em>internet</em> basta especifica-lo após a opção
-A:

<pre>
      iptables -t filter -A internet -s 200.200.200.200 -j DROP
</pre>

<p>
E então criamos um pulo (-j) do chain <em>INPUT</em> para o chain
<em>internet</em>:

<p>
<samp>iptables -t filter -A INPUT -j internet</samp>

<p>
<strong>OBS:</strong> O chain criando pelo usuário pode ter seu nome tanto em
maiúsculas como minúsculas.

<p>
Se uma máquina do endereço 200.200.200.200 tentar acessar sua máquina, o
<code>iptables</code> consultará as seguintes regras:

<pre>
     `INPUT'                         `internet'
      ----------------------------    -----------------------------
      | Regra1: -s 192.168.1.15  |    | Regra1: -s 200.200.200.200|
      |--------------------------|    |---------------------------|
      | Regra2: -s 192.168.1.1   |    | Regra2: -d 192.168.1.1    |
      |--------------------------|    -----------------------------
      | Regra3: -j DROP          |
      ----------------------------
     
     O pacote tem o endereço de origem 
     200.200.200.200, ele passa pela
     primeira e segunda regras do chain
     INPUT, a terceira regra direciona 
     para o chain internet
     
                                         _______________________________________
                                v       /                                      v
      /-------------------------|-\    / /-------------------------------------|-\
      | Regra1: -s 192.168.1.15 | |   /  | Regra1: -s 200.200.200.200 -j DROP  \_____\
      |-------------------------|-|  /   |---------------------------------------|   /
      | Regra2: -s 192.168.1.1  | | /    | Regra2: -d 200.200.200.202 -j DROP    |
      |-------------------------|-|/     \---------------------------------------/
      | Regra3: -j internet      /|
      |---------------------------|       No chain internet, a primeira regra confere
      | Regra4: -j DROP           |       com o endereço de origem 200.200.200.200 e 
      \---------------------------/       o pacote é bloqueado. 
      
     
     Se uma máquina com o endereço de origem 200.200.200.201 tentar acessar a máquina, 
     então as regra consultadas serão as seguintes:
     
     
     O pacote tem o endereço de origem 
     200.200.200.201, ele passa pela
     primeira e segunda regras do chain
     INPUT, a terceira regra direciona 
     para o chain internet               ______________________________________
                                v       /                                      v
      /-------------------------|-\    / /-------------------------------------|-\
      | Regra1: -s 192.168.1.15 | |   /  | Regra1: -s 200.200.200.200 -j DROP  | |
      |-------------------------|-|  /   |-------------------------------------|-|
      | Regra2: -s 192.168.1.1  | | /    | Regra2: -s 200.200.200.202 -j DROP  | |
      |-------------------------|-|/     \-------------------------------------|-/
      | Regra3: -j internet      /|                                            v
      |---------------------------|                                           /
      | Regra4: -j DROP         --+-------------------------------------------      
      \------------------------/-/       O pacote passa pelas regras 1 e 2 do chain
                               |         internet, como ele não confere com nenhuma
                               v         das 2 regras ele retorna ao chain INPUT e é 
      Esta regra é a número 4            analisado pela regra seguinte.
      que diz para rejeitar o 
      pacote.
</pre>

<hr>

<a name="s10.2.7"></a>
<h3>10.2.7 Renomeando um chain criado pelo usuário - E</h3>

<p>
Se por algum motivo precisar renomear um chain criado por você na tabela
<em>filter</em>, <em>nat</em> ou <em>mangle</em>, isto poderá ser feito usando
a opção <em>-E</em> do <code>iptables</code>:

<pre>
     iptables -t filter -E chain-antigo novo-chain
</pre>

<p>
Note que não é possível renomear os chains defaults do <code>iptables</code>.

<hr>

<a name="s10.2.8"></a>
<h3>10.2.8 Listando os nomes de todas as tabelas atuais</h3>

<p>
Use o comando <samp>cat /proc/net/ip_tables_names</samp> para fazer isto.  É
interessante dar uma olhada nos arquivos dentro do diretório
<code>/proc/net</code>, pois os arquivos existentes podem lhe interessar para
outras finalidades.

<hr>

<a name="s-fw-iptables-chains-F"></a>
<h3>10.2.9 Limpando as regras de um chain - F</h3>

<p>
Para limpar todas as regras de um chain, use a seguinte sintaxe:

<p>
<samp>iptables [<em>-t tabela</em>] [<em>-F chain</em>]</samp>

<p>
Onde:
<dl>
<dt><em>tabela</em></dt>
<dd>
Tabela que contém o chain que desejamos zerar.
</dd>
</dl>
<dl>
<dt><em>chain</em></dt>
<dd>
Chain que desejamos limpar.  Caso um chain não seja especificado, todos os
chains da tabela serão limpos.
</dd>
</dl>

<pre>
       iptables -t filter -F INPUT
       iptables -t filter -F
</pre>

<hr>

<a name="s-fw-iptables-chains-X"></a>
<h3>10.2.10 Apagando um chain criado pelo usuário - X</h3>

<p>
Para apagarmos um chain criado pelo usuário, usamos a seguinte sintaxe:

<p>
<samp>iptables [<em>-t tabela</em>] [<em>-X chain</em>]</samp>

<p>
Onde:
<dl>
<dt>tabela</dt>
<dd>
Nome da tabela que contém o chain que desejamos excluir.
</dd>
<dt>chain</dt>
<dd>
Nome do chain que desejamos apagar.  Caso não seja especificado, todos os
chains definidos pelo usuário na tabela especificada serão excluídos.
</dd>
</dl>

<p>
<strong>OBS:</strong> - Chains embutidos nas tabelas não podem ser apagados
pelo usuário.  Veja os nomes destes chains em <a
href="#s-fw-iptables-tabelas">O que são tabelas?, Seção 10.1.14</a>.

<pre>
      iptables -t filter -X internet
      iptables -X
</pre>

<hr>

<a name="s-fw-iptables-chains-Z"></a>
<h3>10.2.11 Zerando contador de bytes dos chains - Z</h3>

<p>
Este comando zera o campo <em>pkts</em> e <em>bytes</em> de uma regra do
<code>iptables</code>.  Estes campos podem ser visualizados com o comando
<code>iptables -L -v</code>.  A seguinte sintaxe é usada:

<p>
<samp>iptables [<em>-t tabela</em>] [<em>-Z chain</em>] [<em>-L</em>]</samp>

<p>
Onde:
<dl>
<dt><em>tabela</em></dt>
<dd>
Nome da tabela que contém o chain que queremos zerar os contadores de bytes e
pacotes.
</dd>
<dt><em>chain</em></dt>
<dd>
Chain que deve ter os contadores zerados.  Caso não seja especificado, todos os
chains da tabela terão os contadores zerados.  Note que as opções <em>-Z</em> e
<em>-L</em> podem ser usadas juntas, assim o chain será listado e imediatamente
zerado.  Isto evita a passagem de pacotes durante a listagem de um chain.
</dd>
</dl>

<pre>
      iptables -t filter -Z INPUT
</pre>

<hr>

<a name="s-fw-iptables-chains-P"></a>
<h3>10.2.12 Especificando o policiamento padrão de um chain - P</h3>

<p>
O policiamento padrão determina o que acontecerá com um pacote quando ele
chegar ao final das regras contidas em um chain.  O policiamento padrão do
<code>iptables</code> é &quot;ACCEPT&quot; mas isto pode ser alterado com o
comando:

<p>
<samp>iptables [<em>-t tabela</em>] [<em>-P chain</em>]
[<em>ACCEPT/DROP</em>]</samp>

<p>
Onde:
<dl>
<dt>tabela</dt>
<dd>
Tabela que contém o chain que desejamos modificar o policiamento padrão.
</dd>
<dt>chain</dt>
<dd>
Define o chain que terá o policiamento modificado.  O chain deve ser
especificado.
</dd>
<dt>ACCEPT/DROP</dt>
<dd>
ACCEPT aceita os pacotes caso nenhuma regra do chain conferir (usado em regras
permissivas).  DROP rejeita os pacotes caso nenhuma regra do chain conferir
(usado em regras restritivas).
</dd>
</dl>

<p>
O policiamento padrão de um chain é mostrado com o comando <code>iptables
-L</code>:

<pre>
     # iptables -L INPUT
     
     Chain INPUT (policy ACCEPT)
     target     prot opt source               destination         
     DROP       icmp --  anywhere             localhost
</pre>

<p>
No exemplo acima, o policiamento padrão de INPUT é ACCEPT (policy ACCEPT), o
que significa que qualquer pacote que não seja rejeitado pela regra do chain,
será aceito.  Para alterar o policiamento padrão deste chain usamos o comando:

<pre>
      iptables -t filter -P INPUT DROP
</pre>

<p>
<strong>NOTA:</strong> Os policiamentos PERMISSIVOS (ACCEPT) normalmente são
usados em conjunto com regras restritivas no chain correspondentes (tudo é
bloqueado e o que sobrar é liberado) e policiamentos RESTRITIVOS (DROP) são
usados em conjunto com regras permissivas no chain correspondente (tudo é
liberado e o que sobrar é bloqueado pelo policiamento padrão).

<hr>

<a name="s-fw-iptables-outras"></a>
<h2>10.3 Outras opções do iptables</h2>

<hr>

<a name="s-fw-iptables-outras-endOD"></a>
<h3>10.3.1 Especificando um endereço de origem/destino</h3>

<p>
As opções <samp>-s</samp> (ou --src/--source)e <samp>-d</samp> (ou
--dst/--destination) servem para especificar endereços de <em>origem</em> e
<em>destino</em> respectivamente.  É permitido usar um endereço IP completo
(como 192.168.1.1), um hostname (debian), um endereço fqdn (www.debian.org) ou
um par <em>rede/máscara</em> (como 200.200.200.0/255.255.255.0 ou
200.200.200.0/24).

<p>
Caso um endereço/máscara não sejam especificados, é assumido <em>0/0</em> como
padrão (todos as máquinas de todas as redes).  A interpretação dos endereços de
origem/destino dependem do chain que está sendo especificado (como INPUT e
OUTPUT por exemplo).

<p>
<strong>OBS:</strong> Caso seja especificado um endereço fqdn e este resolver
mais de um endereço IP, serão criadas várias regras, cada uma se aplicando a
este endereço IP específico.  É recomendável sempre que possível a
especificação de endereços IP's nas regras, pois além de serem muito rápidos
(pois não precisar de resolução DNS) são mais seguros para evitar que nosso
firewall seja enganado por um ataque de IP spoofing.

<pre>
     # Bloqueia o tráfego vindo da rede 200.200.200.*:
      iptables -A INPUT -s 200.200.200.0/24 -j DROP
     
     # Bloqueia conexões com o destino 10.1.2.3:
     iptables -A OUTPUT -d 10.1.2.3 -j DROP
     
     # Bloqueia o tráfego da máquina www.dominio.teste.org a rede 210.21.1.3
     # nossa máquina possui o endereço 210.21.1.3
     iptables -A INPUT -s www.dominio.teste.org -d 210.21.1.3 -j DROP
</pre>

<hr>

<a name="s-fw-iptables-outras-iface"></a>
<h3>10.3.2 Especificando a interface de origem/destino</h3>

<p>
As opções <em>-i</em> (ou --in-interface) e <em>-o</em> (ou --out-interface)
especificam as interfaces de origem/destino de pacotes.  Nem todos as chains
aceitam as interfaces de origem/destino simultaneamente, a interface de entrada
(-i) nunca poderá ser especificada em um chain OUTPUT e a interface de saída
(-o) nunca poderá ser especificada em um chain INPUT.  Abaixo uma rápida
referência:

<pre>
     
               +---------------------+--------------------------------+
       TABELA  |      CHAIN          |            INTERFACE           |
               |                     +----------------+---------------+
               |                     |  ENTRADA (-i)  |    SAÍDA (-o) |
     +---------+---------------------+----------------+---------------+
     |         |  INPUT              |      SIM       |      NÃO      |
     | filter  |  OUTPUT             |      NÃO       |      SIM      |
     |         |  FORWARD            |      SIM       |      SIM      |
     +---------+---------------------+----------------+---------------+
     |         | PREROUTING          |      SIM       |      NÃO      |
     | nat     | OUTPUT              |      NÃO       |      SIM      |
     |         | POSTROUTING         |      NÃO       |      SIM      |
     +---------+---------------------+----------------+---------------+
     |         | PREROUTING          |      SIM       |      NÃO      |
     | mangle  |                     |                |               |
     |         | OUTPUT              |      NÃO       |      SIM      |
     +---------+---------------------+----------------+---------------+
</pre>

<p>
O caminho do pacote na interface será determinado pelo tipo da interface e pela
posição dos chains nas etapas de seu roteamento.  O chain OUTPUT da tabela
filter somente poderá conter a interface de saída (veja a tabela acima).  O
chain FORWARD da tabela filter é o único que aceita a especificação de ambas as
interfaces, este é um ótimo chain para controlar o tráfego que passa entre
interfaces do firewall.

<p>
Por exemplo para bloquear o acesso do tráfego de qualquer máquina com o
endereço 200.123.123.10 vinda da interface ppp0 (uma placa de fax-modem):

<pre>
     iptables -A INPUT -s 200.123.123.10 -i ppp0 -j DROP
</pre>

<p>
A mesma regra pode ser especificada como

<pre>
     iptables -A INPUT -s 200.123.123.10 -i ppp+ -j DROP
</pre>

<p>
O sinal de &quot;+&quot; funciona como um coringa, assim a regra terá efeito em
qualquer interface de ppp0 a ppp9.  As interfaces ativas no momento podem ser
listadas com o comando <code>ifconfig</code>, mas é permitido especificar uma
regra que faz referência a uma interface que ainda não existe, isto é
interessante para conexões intermitentes como o PPP.  Para bloquear qualquer
tráfego local para a Internet:

<pre>
     iptables -A OUTPUT -o ppp+ -j DROP
</pre>

<p>
Para bloquear a passagem de tráfego da interface ppp0 para a interface eth1 (de
uma de nossas redes internas):

<pre>
     iptables -A FORWARD -i ppp0 -o eth1 -j DROP
</pre>

<hr>

<a name="s-fw-iptables-outras-proto"></a>
<h3>10.3.3 Especificando um protocolo</h3>

<p>
A opção <samp>-p</samp> (ou --protocol) é usada para especificar protocolos no
<code>iptables</code>.  Podem ser especificados os protocolos <em>tcp</em>,
<em>udp</em> e <em>icmp</em>.  Por exemplo, para rejeitar todos os pacotes UDP
vindos de 200.200.200.200:

<pre>
      iptables -A INPUT -s 200.200.200.200 -p udp -j DROP
</pre>

<p>
<strong>OBS1:</strong> Tanto faz especificar os nomes de protocolos em
maiúsculas ou minúsculas.

<hr>

<a name="s-fw-iptables-outras-proto-p"></a>
<h4>10.3.3.1 Especificando portas de origem/destino</h4>

<p>
As portas de origem/destino devem ser especificadas após o protocolo e podem
ser precedidas por uma das seguintes opções:
<ul>
<li>
<samp>--source-port ou --sport</samp> - Especifica uma porta ou faixa de portas
de origem.
</li>
<li>
<samp>--destination-port ou --dport</samp> - Especifica uma porta ou faixa de
portas de destino.
</li>
</ul>

<p>
Uma faixa de portas pode ser especificada através de
<samp>PortaOrigem:PortaDestino</samp>:

<pre>
     # Bloqueia qualquer pacote indo para 200.200.200.200 na faixa de 
     # portas 0 a 1023
     iptables -A OUTPUT -d 200.200.200.200 -p tcp --dport :1023 -j DROP
</pre>

<p>
Caso a <em>PortaOrigem</em> de uma faixa de portas não seja especificada, 0 é
assumida como padrão, caso a <em>Porta Destino</em> não seja especificada,
65535 é assumida como padrão.  Caso precise especificar diversas regras que
envolvam o tratamento de portas diferentes, recomendo da uma olhada em <a
href="#s-fw-iptables-mod-multiport">Especificando múltiplas portas de
origem/destino, Seção 10.6.6</a>, antes de criar um grande número de regras.

<hr>

<a name="s-fw-iptables-outras-proto-micmp"></a>
<h4>10.3.3.2 Especificando mensagens do protocolo ICMP</h4>

<p>
O protocolo ICMP não possui portas, mas é possível fazer um controle maior
sobre o tráfego ICMP que entra/sai da rede através da especificação dos tipos
de mensagens ICMP.  Os tipos de mensagens devem ser especificados com a opção
&quot;--icmp-type <em>CódigoICMP</em>&quot; logo após a especificação do
protocolo icmp:

<pre>
     iptables -A INPUT -s 200.123.123.10 -p icmp --icmp-type time-exceeded -i ppp+ -j DROP
</pre>

<p>
A regra acima rejeitará mensagens ICMP do tipo &quot;time-exceeded&quot; (tempo
de requisição excedido) que venham do endereço 200.123.123.10 através da
interface <em>ppp+</em>.

<p>
Alguns tipos de mensagens ICMP são classificados por categoria (como o próprio
&quot;time-exceeded&quot;), caso a categoria &quot;time-exceeded&quot; seja
especificada, todas as mensagens daquela categoria (como
&quot;ttl-zero-during-transit&quot;, &quot;ttl-zero-during-reassembly&quot;)
conferirão na regra especificada.Os tipos de mensagens ICMP podem ser obtidos
com o comando <samp>iptables -p icmp -h</samp>:

<pre>
     echo-reply (pong)
     destination-unreachable
        network-unreachable
        host-unreachable
        protocol-unreachable
        port-unreachable
        fragmentation-needed
        source-route-failed
        network-unknown
        host-unknown
        network-prohibited
        host-prohibited
        TOS-network-unreachable
        TOS-host-unreachable
        communication-prohibited
        host-precedence-violation
        precedence-cutoff
     source-quench
     redirect
        network-redirect
        host-redirect
        TOS-network-redirect
        TOS-host-redirect
     echo-request (ping)
     router-advertisement
     router-solicitation
     time-exceeded (ttl-exceeded)
        ttl-zero-during-transit
        ttl-zero-during-reassembly
     parameter-problem
        ip-header-bad
        required-option-missing
     timestamp-request
     timestamp-reply
     address-mask-request
     address-mask-reply
</pre>

<p>
<strong>OBS1:</strong> Não bloqueie mensagens do tipo
&quot;host-unreachable&quot; e &quot;source-quench&quot;, pois terá sérios
problemas no controle de suas conexões.  A primeira diz que o destino está
inalcançavel e a segunda que o host está sobrecarregado, assim os pacotes devem
ser enviados mais lentamente.

<hr>

<a name="s-fw-iptables-outras-proto-syn"></a>
<h4>10.3.3.3 Especificando pacotes syn</h4>

<p>
Pacotes syn são usados para iniciarem uma conexão, o uso da opção --syn serve
para especificar estes tipos de pacotes.  Desta maneira é possível bloquear
somente os pacotes que iniciam uma conexão, sem afetar os pacotes restantes.
Para que uma conexão ocorra é necessário que a máquina obtenha a resposta a
pacotes syn enviados, caso ele seja bloqueado a resposta nunca será retornada e
a conexão não será estabelecida.

<pre>
     iptables -A INPUT -p tcp --syn --dport 23 -i ppp+ -j DROP
</pre>

<p>
A regra acima bloqueia (-j DROP) qualquer tentativa de conexão (--syn) vindas
da interface ppp+ ao telnet (--dport 23) da máquina local, conexões já
efetuadas ão são afetadas por esta regra.  A opção --syn somente pode ser
especificada para o protocolo tcp.

<p>
<strong>ATENÇÃO:</strong> - A situação de passagem de pacotes durante deve ser
levada em conta durante a inicialização do firewall, bloqueando a passagem de
pacotes durante o processo de configuração, criando regras que bloqueiam a
passagem de pacotes (exceto para a interface loopback) até que a configuração
do firewall esteja completa, pode ser uma solução eficiente.

<p>
Outra alternativa segura é configurar as regras de firewall antes das
interfaces de rede se tornarem ativas (usando a opção &quot;pre-up
comando_firewall&quot; no arquivo de configuração
<code>/etc/network/interfaces</code> em sistemas <code>Debian</code>.

<hr>

<a name="s-fw-iptables-outras-fragmentos"></a>
<h3>10.3.4 Especificando fragmentos</h3>

<p>
A opção &quot;-f&quot; (ou --fragment) permite especificar regras que confiram
com fragmentos.  Fragmentos são simplesmente um pacote maior dividido em
pedaços para poder ser transmitido via rede TCP/IP para remontagem do pacote
pela máquina de destino.

<p>
Somente o primeiro fragmento possui detalhes de cabeçalho para ser processado,
os segundos e seguintes somente possuem alguns cabeçalhos necessários para dar
continuidade ao processo de remontagem do pacote no destino.

<p>
Uma regra como

<pre>
     iptables -A INPUT -s 200.200.200.1 -f -j DROP
</pre>

<p>
derrubará os fragmentos de 200.200.200.1 derrubará o segundo pacote e pacotes
seguintes enviados por 200.200.200.1 até nós.

<p>
<strong>OBS1:</strong> Note que se o cabeçalho do pacote não tiver detalhes
suficientes para checagem de regras no <code>iptables</code>, a regra
simplesmente não ira conferir.

<p>
<strong>OBS2:</strong> Não é preciso especificar a opção &quot;-f&quot; para
conexões NAT, pois os pacotes são remontados antes de entrarem no código de
filtragem.

<p>
<strong>OBS3:</strong> A opção &quot;-f&quot; também pode ser usada para evitar
o flood por fragmentos (bomba de fragmentos) que, dependendo da intensidade,
podem até travar a máquina.

<hr>

<a name="s-fw-iptables-outras-excessoes"></a>
<h3>10.3.5 Especificando uma exceção</h3>

<p>
Muitos parâmetros (como o endereço de origem/destino, protocolo, porta,
mensagens ICMP, fragmentos, etc) podem ser precedidos pelo sinal &quot;!&quot;
que significa exceção.  Por exemplo:

<pre>
     iptables -t filter -A INPUT ! -s 200.200.200.10 -j DROP
</pre>

<p>
Diz para rejeitar todos os pacotes EXCETO os que vem do endereço
<code>200.200.200.10</code>.

<pre>
     iptables -A INPUT -p tcp ! --syn -s 200.200.200.10 ! -i eth0 -j DROP
</pre>

<p>
Diz para bloquear todos os pacotes EXCETO os que iniciam conexões (!  --syn),
EXCETO para pacotes vindos pela interface eth0 (!  -i eth0).

<pre>
     iptables -A INPUT -s 200.200.200.10 ! -p tcp -j DROP
</pre>

<p>
Bloqueia todos os pacotes vindos de 200.200.200.10, EXCETO os do protocolo tcp.

<hr>

<a name="s-fw-iptables-outras-alvo"></a>
<h3>10.3.6 Especificando um alvo</h3>

<p>
O alvo (-j) é o destino que um pacote terá quando conferir com as condições de
uma regra, um alvo pode dizer para bloquear a passagem do pacote (-j DROP),
aceitar a passagem do pacote (-j ACCEPT), registrar o pacote no sistema de log
(-j LOG), rejeitar o pacote (-j REJECT), redirecionar um pacote -j REDIRECT,
retornar ao chain anterior sem completar o processamento no chain atual (-j
RETURN), passar para processamento de programas externos (-j QUEUE), fazer
source nat (-j SNAT), destination nat (-j DNAT), etc.  Podem existir mais
alvos, pois o <code>iptables</code> é modularizável, e módulos que acrescentam
mais funções podem ser carregados em adição aos já existentes no kernel.

<p>
Nos exemplos anteriores vimos o uso de diversos alvos como o DROP e o ACCEPT.
Apenas farei uma breve referência sobre os alvos mais usados em operações
comuns dos chains.  Os alvos REDIRECT, SNAT e DNAT serão explicados em uma
seção seguinte:
<dl>
<dt>ACCEPT</dt>
<dd>
O pacote é ACEITO e o processamento das regras daquele chains é concluído.
Pode ser usado como alvo em todos os chains de todas as tabelas do
<code>iptables</code> e também pode ser especificado no policiamento padrão das
regras do firewall (veja <a href="#s-fw-iptables-chains-P">Especificando o
policiamento padrão de um chain - P, Seção 10.2.12</a>).
</dd>
<dt>DROP</dt>
<dd>
Rejeita o pacote e o processamento das regras daquele chain é concluído.  Pode
ser usado como alvo em todos os chains de todas as tabelas do
<code>iptables</code> e também pode ser especificado no policiamento padrão das
regras do firewall (veja <a href="#s-fw-iptables-chains-P">Especificando o
policiamento padrão de um chain - P, Seção 10.2.12</a>).
</dd>
<dt>REJECT</dt>
<dd>
Este é um módulo opcional que faz a mesma função do alvo <em>DROP</em> com a
diferença de que uma mensagem ICMP do tipo &quot;icmp-port-unreachable&quot;
(TCP/UDP) ou &quot;host-unreachable&quot; (ICMP) é retornada para a máquina de
origem.  Pode ser usado como alvo somente nos chains da tabela (não como
policiamento padrão).
</dd>
<dt>LOG</dt>
<dd>
Este módulo envia uma mensagem ao <code>syslog</code> caso a regra confira, o
processamento continua normalmente para a próxima regra (o pacote não é nem
considerado ACEITO ou REJEITADO).
</dd>
<dt>RETURN</dt>
<dd>
Retorna o processamento do chain anterior sem processar o resto do chain atual.
</dd>
<dt>QUEUE</dt>
<dd>
Passa o processamento para um programa a nível de usuário.
</dd>
</dl>

<hr>

<a name="s-fw-iptables-outras-alvo-REJECT"></a>
<h4>10.3.6.1 Alvo REJECT</h4>

<p>
Para ser usado, o módulo <code>ipt_REJECT</code> deve ser compilado no kernel
ou como módulo.  Este alvo rejeita o pacote (como o <em>DROP</em>) e envia uma
mensagem ICMP do tipo &quot;icmp-port-unreachable&quot; como padrão para a
máquina de origem.

<p>
É um alvo interessante para bloqueio de portas TCP, pois em alguns casos da a
impressão que a máquina não dispõe de um sistema de firewall (o alvo DROP causa
uma parada de muito tempo em alguns portscanners e tentativas de conexão de
serviços, revelando imediatamente o uso de um sistema de firewall pela
máquina).  O alvo REJECT vem dos tempos do ipchains e somente pode ser usado na
tabela <em>filter</em>.  Quando um pacote confere, ele é rejeitado com a
mensagem ICMP do tipo &quot;port unreachable&quot;, é possível especificar
outro tipo de mensagem ICMP com a opção <em>--reject-with tipo_icmp</em>.

<p>
<strong>OBS:</strong> REJECT pode ser usado somente como alvo na tabela filter
e não é possível especifica-lo como policiamento padrão do chain filter (como
acontecia no <code>ipchains</code>.  Uma forma alternativa é inserir como
última regra uma que pegue todos os pacotes restantes daquele chain e tenha
como alvo REJECT (como <samp>iptables -A INPUT -j REJECT</samp>), desta forma
ele nunca atingirá o policiamento padrão do chain.

<pre>
     # Rejeita pacotes vindos de 200.200.200.1 pela interface ppp0: 
     iptables -A INPUT -s 200.200.200.1 -i ppp+ -j REJECT
</pre>

<hr>

<a name="s-fw-iptables-outras-alvo-LOG"></a>
<h4>10.3.6.2 Especificando LOG como alvo</h4>

<p>
Este alvo é usado para registrar a passagem de pacotes no <code>syslog</code>
do sistema.  É um alvo muito interessante para ser usado para regras que
bloqueiam determinados tráfegos no sistema (para que o administrador tome
conhecimento sobre tais tentativas), para regras de fim de chain (quando você
tem um grande conjunto de regras em um firewall restritivo e não sabe onde suas
regras estão sendo bloqueadas), para satisfazer sua curiosidade, etc.

<pre>
     # Para registrar o bloqueio de pacotes vindos de 200.200.200.1 pela interface ppp0
     iptables -A INPUT -s 200.200.200.1 -i ppp+ -j LOG
     # Para efetuar o bloqueio
     iptables -A INPUT -s 200.200.200.1 -i ppp+ -j REJECT
</pre>

<p>
Note que no exemplo anterior a regra que registra o pacote (-j LOG) deve
aparecer antes da regra que REJEITA (-j REJECT), caso contrário a regra de LOG
nunca funcionará.  A regra que REJEITA poderia também ser trocada por uma regra
que ACEITA, caso queira registrar um pacote que deve ser aceito (se o
policiamento padrão do seu firewall for restritivo (-P DROP).  A única coisa
que muda nas regras de log é o alvo da regra, isto facilita a implementação de
grandes conjuntos de regras de firewall.

<p>
A regra acima mostrará a seguinte saída no <code>syslog</code> do sistema:

<pre>
     Aug 25 10:08:01 debian kernel: IN=ppp0 OUT= MAC=10:20:30:40:50:60:70:80:90:00:00:00:08:00 SRC=200.200.200.1 DST=200.210.10.10 LEN=61 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=UDP SPT=1031 DPT=53 LEN=41
</pre>

<p>
Os campos possuem o seguinte significado:
<dl>
<dt>Aug 25 10:08:01</dt>
<dd>
Mês, dia e hora do registro do pacote.
</dd>
<dt>debian</dt>
<dd>
Nome do computador que registrou o pacote.
</dd>
<dt>kernel:</dt>
<dd>
Daemon que registrou a mensagem, no caso o <code>iptables</code> faz parte do
próprio kernel.
</dd>
<dt>IN=ppp0</dt>
<dd>
Especifica a interface de entrada (de onde o pacote veio).
</dd>
<dt>OUT=</dt>
<dd>
Especifica a interface de saída (para onde o pacote foi).
</dd>
<dt>MAC=10:20:30:40:50:60:70:80:90:00:00:00:08:00</dt>
<dd>
Endereço mac da interface de rede (pode ser obtido com <samp>arp
interface</samp>).
</dd>
<dt>SRC=200.200.200.1</dt>
<dd>
Endereço de origem do pacote.
</dd>
<dt>DST=200.210.10.10</dt>
<dd>
Endereço de destino do pacote.
</dd>
<dt>SEQ=234234343</dt>
<dd>
Número de seqüência da recepção.  É ativado com a opção
<em>--log-tcp-sequence</em>.
</dd>
<dt>LEN=61</dt>
<dd>
Tamanho em bytes do pacote IP.
</dd>
<dt>TOS=0x00</dt>
<dd>
Prioridade do cabeçalho TOS (Tipo).  Veja a seção <a
href="#s-fw-iptables-mangle-TOS">Especificando o tipo de serviço, Seção
10.5.1</a> para mais detalhes.
</dd>
<dt>PREC=0x00</dt>
<dd>
Prioridade do cabeçalho TOS (Precedência).  Veja a seção <a
href="#s-fw-iptables-mangle-TOS">Especificando o tipo de serviço, Seção
10.5.1</a> para mais detalhes.
</dd>
<dt>TTL=64</dt>
<dd>
Tempo de vida do pacote.  No exemplo, 64 roteadores (hops).
</dd>
<dt>ID=0</dt>
<dd>
Identificação única destes datagrama.  Esta identificação também é usada pelos
fragmentos seguintes deste pacote.
</dd>
<dt>DF</dt>
<dd>
Opção &quot;Don't fragment&quot; (não fragmentar) do pacote.  Usada quando o
pacote é pequeno o bastante para não precisar ser fragmentado.
</dd>
<dt>MF</dt>
<dd>
Opção &quot;More Fragments&quot; (mais fragmentos) estão para ser recebidos.
</dd>
<dt>FRAG=100</dt>
<dd>
Tamanho do fragmento especificado em pacotes de 8 bits.  No exemplo acima, o
pacote tem o tamanho de 800 bytes (100*8).
</dd>
<dt>PROTO=UDP</dt>
<dd>
Nome do protocolo.  Pode ser TCP, UDP ou ICMP
</dd>
<dt>SPT=1031</dt>
<dd>
Porta de origem da requisição.
</dd>
<dt>DPT=53</dt>
<dd>
Porta de destino da requisição.
</dd>
<dt>LEN=41</dt>
<dd>
Tamanho do pacote.
</dd>
</dl>

<p>
O log acima mostra uma consulta DNS (porta destino 53) para nossa máquina
(INPUT) de 200.200.200.1 para 200.210.10.10.

<p>
O problema é que em um grande número de regras será difícil saber qual regra
conferiu (pois teríamos que analisar o endereço/porta origem/destino) e o
destino do pacote (se ele foi ACEITO ou BLOQUEADO) pois você pode ter regras
para ambas as situações.  Por este motivo existem algumas opções úteis que
podemos usar com o alvo LOG:
<dl>
<dt>--log-prefix &quot;descrição&quot;</dt>
<dd>
Permite especificar uma descrição para a regra do firewall de até 29
caracteres.  Caso tiver espaços, devem ser usadas &quot;aspas&quot;.
</dd>
<dt>--log-level nível</dt>
<dd>
Especifica o nível da mensagem no <code>syslog</code>.
</dd>
<dt>--log-tcp-options</dt>
<dd>
Registra campos do cabeçalho TCP nos logs do sistema.
</dd>
<dt>--log-ip-options</dt>
<dd>
Registra campos do cabeçalho IP nos logs do sistema
</dd>
<dt>--log-tcp-sequence</dt>
<dd>
Registra os números de seqüencia TCP.  Evite ao máximo o uso desta opção, pois
a seqüencia de números TCP pode ser a chave para um seqüestro de seção ou IP
spoofing em seu sistema caso algum usuário tenha acesso a estes logs.  Caso
utilize tcp/ip em servidores públicos, o uso desta opção ajudará a entender bem
os ataques DoS causados por syn-flood e porque ativar os SynCookies (veja <a
href="#s-fw-iptables-mod-limit-synflood">Proteção contra syn flood, Seção
10.6.4</a>).
</dd>
</dl>

<p>
<strong>OBS1:</strong>Lembre-se que estas opções são referentes ao alvo LOG e
devem ser usadas após este, caso contrário você terá um pouco de trabalho para
analisar e consertar erros em suas regras do firewall.

<p>
<strong>OBS2:</strong>Caso esteja usando o firewall em um servidor público,
recomendo associar um limite a regra de log, pois um ataque poderia causar um
DoS enchendo sua partição.  Leia mais sobre isso em <a
href="#s-fw-iptables-mod-limit">Limitando o número de vezes que a regra
confere, Seção 10.6.2</a>.

<pre>
     # Complementando o exemplo anterior:
     # Para registrar o bloqueio de pacotes vindos de 200.200.200.1 pela interface ppp0
     iptables -A INPUT -s 200.200.200.1 -i ppp+ -j LOG --log-prefix &quot;FIREWALL: Derrubado &quot;
     # Para efetuar o bloqueio
     iptables -A INPUT -s 200.200.200.1 -i ppp+ -j REJECT
</pre>

<p>
Retornará a seguinte mensagem no syslog:

<pre>
     Aug 25 10:08:01 debian kernel: FIREWALL: Derrubado IN=ppp0 OUT= MAC=10:20:30:40:50:60:70:80:90:00:00:00:08:00 SRC=200.200.200.1 DST=200.210.10.10 LEN=61 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=UDP SPT=1031 DPT=53 LEN=41
</pre>

<p>
Agora você sabe o que aconteceu com o pacote (Rejeitado).  A padronização de
mensagens de firewall é também importante para a criação de scripts de análise
que poderão fazer a análise dos logs do seu firewall (para criação de
estatísticas que podem servir como base para a criação de novas regras de
firewall ou eliminação de outras).

<p>
<strong>OBS:</strong> Se você sente falta da função &quot;-l&quot; do
<code>ipchains</code> que combina o alvo e log na mesma regra você pode criar
um alvo como o seguinte:

<pre>
     iptables -N log-drop
     iptables -A log-drop -j LOG
     iptables -A log-drop -j DROP
</pre>

<p>
E usar &quot;log-drop&quot; como alvo em suas regras.  Mesmo assim esta solução
é &quot;limitada&quot; em relação a &quot;-l&quot; do <code>ipchains</code>
porque o <code>iptables</code> não inclui detalhes de qual chain bloqueou o
pacote/qual pacote foi bloqueado, assim é necessário a especificação da opção
<em>--log-prefix</em> para as mensagens se tornarem mais compreensíveis.  Esta
limitação pode ser contornada utilizando um firewall feito em linguagem shell
script, desta forma você terá um controle maior sobre o seu programa usando
funções e integração com outros utilitários.

<hr>

<a name="s-fw-iptables-outras-alvo-RETURN"></a>
<h4>10.3.6.3 Especificando RETURN como alvo</h4>

<p>
O alvo RETURN diz ao <code>iptables</code> interromper o processamento no chain
atual e retornar o processamento ao chain anterior.  Ele é útil quando criamos
um chain que faz um determinado tratamento de pacotes, por exemplo bloquear
conexões vindas da internet para portas baixas, exceto para um endereço IP
específico.  Como segue:

<pre>
     1-) iptables -t filter -A INPUT -i ppp0 -j internet
     2-) iptables -t filter -j ACCEPT
     3-) iptables -t filter -N internet
     4-) iptables -t filter -A internet -s www.debian.org -p tcp --dport 80 -j RETURN
     5-) iptables -t filter -A internet -p tcp --dport 21 -j DROP
     6-) iptables -t filter -A internet -p tcp --dport 23 -j DROP
     7-) iptables -t filter -A internet -p tcp --dport 25 -j DROP
     8-) iptables -t filter -A internet -p tcp --dport 80 -j DROP
</pre>

<p>
Quando um pacote com o endereço <code>www.debian.org</code> tentando acessar a
porta www (80) de nossa máquina através da internet (via interface ppp0), o
chain número 1 confere, então o processamento continua no chain número 4, o
chain número 4 confere então o processamento volta para a regra número 2, que
diz para aceitar o pacote.

<p>
Agora se um pacote vem com o endereço <code>www.dominio.com.br</code> tentando
acessar a porta www *80) de nossa máquina através da internet (via interface
ppp0), o chain número 1 confere, então o processamento continua no chain número
4, que não confere.  O mesmo acontece com os chains 5, 6 e 7.  O chain número 8
confere, então o acesso é bloqueado.

<p>
Como pode notou, o alvo RETURN facilita bastante a construção das regras do seu
firewall, caso existam máquinas/redes que sejam exceções as suas regras.  Se
ela não existisse, seria necessário especificar diversas opções -s, -d, etc
para poder garantir o acesso livre a determinadas máquinas.

<hr>

<a name="s-fw-iptables-outras-save-restore"></a>
<h3>10.3.7 Salvando e Restaurando regras</h3>

<p>
As regras que você está trabalhosamente criando e testando manualmente enquanto
manipula o <code>iptables</code> podem ser salvas de 2 formas; uma delas é
escrevendo um shell script que tenha todos os comandos, um por linha.  Isto é
recomendado quando tem um firewall grande e que exige uma boa padronização de
regras, bem como sua leitura, comentários.  O script shell também permite o uso
de funções presente no interpretador de comando, portanto se você é uma pessoa
que gosta de interagir com as funções do shell e deixar as coisas mais
flexíveis, prefira esta opção.

<p>
A outra forma é usando as ferramentas <code>iptables-save</code> e
<code>iptables-restore</code> baseada na idéia do <code>ipchains-save</code> e
<code>ipchains-restore</code>.  O <code>iptables-save</code> deve ser usado
sempre que modificar regras no firewall iptables da seguinte forma:

<pre>
     iptables-save &gt;/dir/iptables-regras
</pre>

<p>
Uma das vantagens do uso do <code>iptables-save</code> é ele também salvar os
contadores de chains, ou seja, a quantidade de pacotes que conferiram com a
regra.  Isto também pode ser feito com algumas regras adicionais em seu shell
script, caso tenha interesse nesses contadores para estatísticas ou outros
tipos de relatórios.

<p>
Para restaurar as regras salvas, utilize o comando:

<pre>
     iptables-restore &lt;/dir/iptables-regras
</pre>

<hr>

<a name="s-fw-iptables-nat"></a>
<h2>10.4 A tabela nat (Network Address Translation) - fazendo nat</h2>

<p>
A tabela <em>nat</em> serve para controlar a tradução dos endereços que
atravessam o código de roteamento da máquina <code>Linux</code>.  Existem 3
chains na tabela <em>nat</em>: <em>PREROUTING</em>, <em>OUTPUT</em> e
<em>POSTROUTING</em> (veja <a href="#s-fw-iptables-tabelas">O que são tabelas?,
Seção 10.1.14</a> para maiores detalhes).

<p>
A tradução de endereços tem inúmeras utilidades, uma delas é o Masquerading,
onde máquinas de uma rede interna podem acessar a Internet através de uma
máquina <code>Linux</code>, redirecionamento de porta, proxy transparente, etc.
Esta seção abordará os tipos de NAT, exemplos de como criar rapidamente uma
conexão IP masquerading e entender como a tradução de endereços funciona no
<code>iptables</code>.

<p>
Se sua intenção é ligar sua rede a Internet existem duas opções:
<ul>
<li>
Você possui uma conexão que lhe oferece um endereço IP dinâmico (a cada conexão
é dado um endereço IP - como uma conexão PPP) então o IP masquerading é o que
precisa (veja <a href="#s-fw-iptables-nat-fastmasquerade">Fazendo IP
masquerading (para os apressados), Seção 10.4.2</a> ou <a
href="#s-fw-iptables-nat-snat-masquerade">Fazendo IP Masquerading, Seção
10.4.3.1</a>).
</li>
<li>
Você tem uma conexão que lhe oferece um endereço IP permanente (ADSL, por
exemplo) então o SNAT é o que precisa (veja <a
href="#s-fw-iptables-nat-snat">Fazendo SNAT, Seção 10.4.3</a>).
</li>
</ul>

<hr>

<a name="s-fw-iptables-nat-N"></a>
<h3>10.4.1 Criando um novo chain na tabela NAT</h3>

<p>
O procedimento para criação de um novo chain nesta tabela é o mesmo descrito em
<a href="#s-fw-iptables-chains-N">Criando um novo chain - N, Seção 10.2.6</a>
será necessário somente especificar a tabela nat (-t nat) para que o novo chain
não seja criado na tabela padrão (-t filter).

<pre>
     iptables -t nat -N intra-inter
</pre>

<p>
Que criará o chain chamado <em>intra-inter</em> na tabela <em>nat</em>.  Para
inserir regras neste chain será necessário especificar a opção &quot;-t
nat&quot;.

<hr>

<a name="s-fw-iptables-nat-fastmasquerade"></a>
<h3>10.4.2 Fazendo IP masquerading (para os apressados)</h3>

<p>
Você precisará de um kernel com suporte ao <code>iptables</code> (veja <a
href="#s-fw-iptables-supkernel">Habilitando o suporte ao iptables no kernel,
Seção 10.1.15</a> e <code>ip_forward</code> e então digitar os dois comandos
abaixo para habilitar o masquerading para todas as máquinas da rede
192.168.1.*:

<pre>
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -j MASQUERADE
     echo &quot;1&quot; &gt;/proc/sys/net/ipv4/ip_forward
</pre>

<p>
A configuração do servidor <code>Linux</code> está completa, agora os clientes
da rede precisarão ser configurados para usar o endereço IP do servidor
<code>Linux</code> como gateway.  É recomendável instalar um servidor proxy e
DNS na máquina <code>Linux</code> para acelerar o desempenho das
requisições/resolução de nomes das máquinas em rede.  A utilização de bits TOS
também pode trazer um grande aumento de velocidade para os diferentes serviços
da rede (veja <a href="#s-fw-iptables-mangle-TOS">Especificando o tipo de
serviço, Seção 10.5.1</a>).

<hr>

<a name="s-fw-iptables-nat-snat"></a>
<h3>10.4.3 Fazendo SNAT</h3>

<p>
SNAT (source nat - nat no endereço de origem) consiste em modificar o endereço
de origem das máquinas clientes antes dos pacotes serem enviados.  A máquina
roteadora é inteligente o bastante para lembrar dos pacotes modificados e
reescrever os endereços assim que obter a resposta da máquina de destino,
direcionando os pacotes ao destino correto.  Toda operação de SNAT é feita no
chain <em>POSTROUTING</em>.

<p>
É permitido especificar endereços de origem/destino, protocolos, portas de
origem/destino, interface de entrada/saída (dependendo do chain), alvos, etc.
É desnecessário especificar fragmentos na tabela nat, pois eles serão
remontados antes de entrar no código de roteamento.

<p>
O SNAT é a solução quando você tem acesso a internet através de um único IP e
deseja fazer que sua rede tenha acesso a Internet através da máquina
<code>Linux</code>.  Nenhuma máquina da Internet poderá ter acesso direto as
máquinas de sua rede interna via SNAT.

<p>
<strong>OBS:</strong> A observação acima não leva em conta o controle de acesso
externo configurado na máquina que estiver configurando o
<code>iptables</code>, uma configuração mau realizada pode expor sua máquina a
acessos externos indesejados e comprometer sua rede interna caso alguém consiga
acesso direto ao servidor.

<p>
É necessário especificar SNAT como alvo (-j SNAT) quando desejar que as
máquinas de sua rede interna tenha acesso a Internet através do IP fixo da
máquina <code>Linux</code> (para conexões intermitentes como PPP, veja <a
href="#s-fw-iptables-nat-snat-masquerade">Fazendo IP Masquerading, Seção
10.4.3.1</a>).  O parâmetro <samp>--to IP:portas</samp> deve ser usado após o
alvo SNAT.  Ele serve para especificar um endereço IP, faixa de endereços e
opcionalmente uma porta ou faixa de portas que será substituída.  Toda a
operação de SNAT é realizada através do chain POSTROUTING:

<pre>
     # Modifica o endereço IP dos pacotes vindos da máquina 192.168.1.2 da rede interna 
     # que tem como destino a interface eth1 para 200.200.217.40 (que é o nosso endereço 
     # IP da interface ligada a Internet). 
     iptables -t nat -A POSTROUTING -s 192.168.1.2 -o eth1 -j SNAT --to 200.200.217.40
</pre>

<p>
Os pacotes indo para a Internet (nossa conexão é feita via eth1, nossa
interface externa) vindo do endereço 192.168.1.2, são substituídos por
200.241.200.40 e enviados para fora.  Quando a resposta a requisição é
retornada, a máquina com <code>iptables</code> recebe os pacotes e faz a
operação inversa, modificando o endereço 200.241.200.40 novamente para
192.168.1.2 e enviando a resposta a máquina de nossa rede interna.  Após
definir suas regras de NAT, execute o comando <samp>echo &quot;1&quot;
&gt;/proc/sys/net/ipv4/ip_forward</samp> para habilitar o suporte a
redirecionamento de pacotes no kernel.

<p>
Também é possível especificar faixas de endereços e portas que serão
substituídas:

<pre>
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 200.200.217.40-200.200.217.50
</pre>

<p>
Modifica o endereço IP de origem de todas as máquinas da rede 192.168.1.0/24
que tem o destino a interface eth0 para 200.241.200.40 a 200.241.200.50.  O
endereço IP selecionado é escolhido de acordo com o último IP alocado.

<pre>
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 200.200.217.40-200.200.217.50:1-1023
</pre>

<p>
Idêntico ao anterior, mas faz somente substituições na faixa de portas de
origem de 1 a 1023.

<pre>
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j SNAT --to 200.200.217.40-200.200.217.50 --to 200.200.217.70-200.200.217.73
</pre>

<p>
Faz o mapeamento para a faixa de portas 200.200.217.40 a 200.200.217.50 e de
200.200.217.70 a 200.200.217.73.

<p>
<strong>OBS1:</strong> Se por algum motivo não for possível mapear uma conexão
NAT, ela será derrubada.

<p>
<strong>OBS2:</strong> Tenha certeza que as respostas podem chegar até a
máquina que fez o NAT.  Se estiver fazendo SNAT em um endereço livre em sua
rede (como 200.200.217.73).

<p>
<strong>OBS3:</strong> Como notou acima, o SNAT é usado quando temos uma
conexão externa com um ou mais IP's fixos.  O Masquerading é uma forma especial
de SNAT usada para funcionar em conexões que recebem endereços IP aleatórios
(PPP).

<p>
<strong>OBS4:</strong> Não se esqueça de habilitar o redirecionamento de
pacotes após fazer suas regra de NAT com o comando: <samp>echo &quot;1&quot;
&gt;/proc/sys/net/ipv4/ip_forward</samp>, caso contrário o redirecionamento de
pacotes não funcionará.

<hr>

<a name="s-fw-iptables-nat-snat-masquerade"></a>
<h4>10.4.3.1 Fazendo IP Masquerading</h4>

<p>
O IP Masquerading é um tipo especial de SNAT usado para conectar a sua rede
interna a internet quando você recebe um IP dinâmico de seu provedor (como em
conexões ppp).  Todas as operações de IP Masquerading são realizadas no chain
<em>POSTROUTING</em>.  Se você tem um IP fixo, deve ler <a
href="#s-fw-iptables-nat-snat">Fazendo SNAT, Seção 10.4.3</a>.

<p>
Para fazer IP Masquerading de uma máquina com o IP 192.168.1.2 para ter acesso
a Internet, use o comando:

<pre>
     iptables -t nat -A POSTROUTING -s 192.168.1.2/32 -o ppp0 -j MASQUERADE
</pre>

<p>
A diferença é que o alvo é <em>-j MASQUERADE</em>.  O comando acima faz IP
Masquerading de todo o tráfego de 192.168.1.2 indo para a interface ppp0: O
endereço IP dos pacotes vindos de 192.168.1.2 são substituídos pelo IP
oferecido pelo seu provedor de acesso no momento da conexão, quando a resposta
é retornada a operação inversa é realizada para garantir que a resposta chegue
ao destino.  Nenhuma máquina da internet poderá ter acesso direto a sua máquina
conectava via Masquerading.

<p>
Para fazer o IP Masquerading de todas as máquinas da rede 192.168.1.*:

<pre>
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp0 -j MASQUERADE
</pre>

<p>
Após definir a regra para fazer Masquerading (SNAT), execute o comando
<samp>echo &quot;1&quot; &gt;/proc/sys/net/ipv4/ip_forward</samp> para
habilitar o suporte a redirecionamento de pacotes no kernel.

<hr>

<a name="s-fw-iptables-nat-dnat"></a>
<h3>10.4.4 Fazendo DNAT</h3>

<p>
DNAT (Destination nat - nat no endereço de destino) consiste em modificar o
endereço de destino das máquinas clientes.  O destination nat é muito usado
para fazer redirecionamento de pacotes, proxyes transparentes e balanceamento
de carga.

<p>
Toda operação de DNAT é feita no chain <em>PREROUTING</em>.  As demais opções e
observações do SNAT são também válidas para DNAT (com exceção que somente é
permitido especificar a interface de origem no chain PREROUTING).

<pre>
     # Modifica o endereço IP destino dos pacotes de 200.200.217.40 vindo da interface eth0
     # para 192.168.1.2. 
     iptables -t nat -A PREROUTING -s 200.200.217.40 -i eth0 -j DNAT --to 192.168.1.2
</pre>

<p>
Também é possível especificar faixas de endereços e portas que serão
substituídas no DNAT:

<pre>
     iptables -t nat -A PREROUTING -i eth0 -s 192.168.1.0/24 -j DNAT --to 200.200.217.40-200.200.217.50
</pre>

<p>
Modifica o endereço IP de destino do tráfego vindos da interface 192.168.1.0/24
para um IP de 200.241.200.40 a 200.241.200.50.  Este é um excelente método para
fazer o balanceamento de carga entre servidores.  O endereço IP selecionado é
escolhido de acordo com o último IP alocado.

<pre>
     iptables -t nat -A PREROUTING -i eth0 -s 192.168.1.0/24 -j DNAT --to 200.200.217.40-200.200.217.50:1024:5000
</pre>

<p>
Idêntico ao anterior, mas faz somente substituições na faixa de portas de
destino de 1024 a 5000.  A operação acima é a mesma realizada pelo
<code>ipmasqadm</code> dos kernels da série 2.2.

<p>
<strong>OBS1:</strong> Se por algum motivo não for possível mapear uma conexão
NAT, ela será derrubada.

<p>
<strong>OBS2:</strong> Não se esqueça de conferir se o <code>ip_forward</code>
está ajustado para <samp>1</samp>: <samp>echo &quot;1&quot;
&gt;/proc/sys/net/ipv4/ip_forward</samp>.

<hr>

<a name="s-fw-iptables-nat-dnat-redir"></a>
<h4>10.4.4.1 Redirecionamento de portas</h4>

<p>
O redirecionamento de portas permite a você repassar conexões com destino a uma
porta para outra porta na mesma máquina.  O alvo <em>REDIRECT</em> é usado para
fazer esta operação, junto com o argumento <em>--to-port</em> especificando a
porta que será redirecionada.  Este é o método DNAT específico para se para
fazer proxy transparente (para redirecionamento de endereços/portas, veja <a
href="#s-fw-iptables-nat-dnat">Fazendo DNAT, Seção 10.4.4</a>).  Todas as
operações de redirecionamento de portas é realizada no chain
<em>PREROUTING</em> e <em>OUTPUT</em> da tabela <em>nat</em>.

<pre>
     iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 81
</pre>

<p>
Redireciona as conexões indo para a porta 80 para a porta 81 (rodando
<code>squid</code>) no firewall.

<p>
<strong>ATENÇÃO:</strong> O <code>squid</code> possui suporte a proxy
transparente, e poderá atender as requisições acima da regra acima.

<hr>

<a name="s-fw-iptables-nat-monitorando"></a>
<h3>10.4.5 Monitorando conexões feitas na tabela nat</h3>

<p>
Use o comando <samp>cat /proc/net/ip_conntrack</samp> para listar todas as
conexões atuais tratadas pelo módulo nat.

<hr>

<a name="s-fw-iptables-mangle"></a>
<h2>10.5 A tabela mangle</h2>

<p>
A tabela <em>mangle</em> serve para especificar ações especiais para o
tratamento do tráfego que atravessa os chains.  Nesta tabela existem cincos
chains: <em>PREROUTING</em>, <em>POSTROUTING</em>, <em>INPUT</em>,
<em>OUTPUT</em> e <em>FORWARD</em> (veja <a href="#s-fw-iptables-tabelas">O que
são tabelas?, Seção 10.1.14</a> para maiores detalhes).

<p>
Em geral, cada um deste chain é processado antes do chain correspondente na
tabela <em>filter</em> e <em>nat</em> para definir opções especiais para o
tráfego (por exemplo, o chain <em>PREROUTING</em> da tabela <em>mangle</em> é
processado antes do <em>PREROUTING</em> da tabela <em>nat</em>).  O chain
<em>OUTPUT</em> da tablea <em>mangle</em> corresponde ao <em>OUTPUT</em> da
tabela <em>nat</em>.  Opções como o <em>Tipo de Serviço (TOS)</em> é
especificado nesta tabela para classificar e aumentar consideravelmente a
velocidade de tráfego considerados em tempo real.  Mesmo após o tráfego ser
estabelecido, os chains da tabela mangle continuam ativos para garantir que as
opções especiais relacionadas com a conexão continuem fazendo efeito (veja os
exemplos de <a href="#s-fw-iptables-path">Caminho percorrido pelos pacotes nas
tabelas e chains, Seção 10.7</a>).

<hr>

<a name="s-fw-iptables-mangle-TOS"></a>
<h3>10.5.1 Especificando o tipo de serviço</h3>

<p>
O tipo de serviço é um campo existente no cabeçalho de pacotes do protocolo
ipv4 que tem a função especificar qual é a prioridade daquele pacote.  A
prioridade é definida usando o algoritmo FIFO do próprio kernel, sendo uma das
alternativas de controle/priorização de tráfego das mais simples e rápidas.

<p>
Uma das vantagens da utilização do tipo de serviço é dar prioridade ao tráfego
de pacotes interativos (como os do ICQ, IRC, servidores de chat), etc.  Com o
TOS especificado, mesmo que esteja fazendo um download consumindo toda a banda
de sua interface de rede, o tráfego com prioridade interativa será enviado
antes, aumentando a eficiência do uso de serviços em sua máquina.

<p>
Em testes realizados em minha conexão de 56K, o uso de regras TOS aumentou
bastante o desempenho em tráfego interativo (em torno de 300%), durante o uso
total da banda da interface ppp em grande consumo de banda.

<p>
Usamos o alvo TOS (-j TOS) para especificar a modificação do tipo de serviço
nos pacotes que atravessam as regras do firewall, acompanhada do argumento
<em>--set-tos TOS</em> que define a nova prioridade dos pacotes.  Os valores
aceitos são os seguintes:
<dl>
<dt>Espera Mínima</dt>
<dd>
É especificado através de <em>Minimize-Delay</em>, <em>16</em> ou <em>0x10</em>
</dd>
<dt>Máximo Processamento</dt>
<dd>
É especificado através de <em>Maximize-Throughput</em>, <em>8,</em> ou
<em>0x08</em>.
</dd>
<dt>Máxima Confiança</dt>
<dd>
É especificado através de <em>Maximize-Reliability</em>, <em>4</em> ou
<em>0x04</em>.
</dd>
<dt>Custo mínimo</dt>
<dd>
Especificado através de <em>Minimize-Cost</em>, <em>2</em> ou <em>0x02</em>.
</dd>
<dt>Prioridade Normal</dt>
<dd>
Especificado através de <em>Normal-Service</em>, <em>0</em> ou <em>0x00</em>.
</dd>
</dl>

<p>
Os pacotes vem por padrão com o valor TOS ajustado como <em>prioridade
normal</em> (bits tos ajustados para 0x00).  O tipo <em>Mínima Espera</em> é o
de maior prioridade, recomendado para tráfego interativo.

<hr>

<a name="s-fw-iptables-mangle-TOS-out"></a>
<h4>10.5.1.1 Especificando o TOS para tráfego de saída</h4>

<p>
Este é o mais usado, pois prioriza o tráfego que sai da máquina (com destino a
Internet, por exemplo).  Sua operação é realizada através do chain
<em>OUTPUT</em> ou <em>POSTROUTING</em>.

<p>
Para priorizar todo o tráfego de IRC de nossa rede interna indo para a
interface ppp0:

<pre>
     iptables -t mangle -A OUTPUT -o ppp0 -p tcp --dport 6666-6668 -j TOS --set-tos 16
</pre>

<p>
O bit TOS é ajustado para <em>Espera mínima</em> e será enviado antes dos
pacotes com prioridade normal para fora.  Para priorizar a transmissão de dados
ftp saindo da rede:

<pre>
     iptables -t mangle -A OUTPUT -o ppp0 -p tcp --dport 20 -j TOS --set-tos 8
</pre>

<p>
Para priorizar o tráfego de ICQ da rede:

<pre>
     iptables -t mangle -A OUTPUT -o ppp0 -p tcp --dport 5190 -j TOS --set-tos 16
</pre>

<p>
Existem muitas outras otimizações que podem ser feitas, só depende dos
requerimentos e análise de cada serviço da rede pelo administrador.

<p>
<strong>OBS:</strong> - Os pacotes que atravessam o alvo TOS somente tem os
bits tipo do serviço modificados, eles não serão de qualquer forma rejeitados.

<hr>

<a name="s-fw-iptables-mangle-TOS-in"></a>
<h4>10.5.1.2 Especificando o TOS para o tráfego de entrada</h4>

<p>
Este prioriza o tráfego que entra da máquina.  Sua operação é realizada no
chain <em>INPUT</em> ou <em>PREROUTING</em>.  Não faz muito sentido o uso deste
chain dentro de uma rede pequena/média, pois o tráfego que recebermos será
priorizado pelo chain de saída de outras máquinas da internet/outras redes
antes de chegar a nossa (desde que elas também estejam usando TOS).

<p>
Para priorizar o processamento do tráfego interativo vindo de servidores IRC
para nossa rede:

<pre>
     iptables -t mangle -A PREROUTING -i eth0 -p tcp --sport 6666-6668 -j TOS --set-tos 0x10
</pre>

<p>
Modifica o tipo de serviço para <em>mínima espera</em> de todo o tráfego
enviado por servidores de IRC vindo da interface eth0.

<p>
<strong>OBS:</strong> - Os pacotes que atravessam o alvo TOS somente tem os
bits tipo do serviço modificados, eles não serão de qualquer forma rejeitados.
\

<hr>

<a name="s-fw-iptables-mod"></a>
<h2>10.6 Outros módulos do iptables</h2>

<p>
Os módulos do iptables são especificados com a opção <em>-m módulo</em> ou
<em>--match módulo</em> e permitem expandir a funcionalidade do firewall
através de novas conferências e recursos de filtragem adicionais, como limitar
a conferência de regras do firewall (um método útil de limitar ping floods, syn
floods, etc).

<hr>

<a name="s-fw-iptables-mod-state"></a>
<h3>10.6.1 Conferindo de acordo com o estado da conexão</h3>

<p>
Este módulo permite especificar regras de acordo com o estado da conexão do
pacote, isto é feito através da interpretação da saída do módulo
<code>ip_conntrack</code>.  O parâmetro <em>--state OPÇÕES</em> deve acompanhar
este módulo.  As opções permitidas são as seguintes:
<ul>
<li>
<samp>NEW</samp> - Confere com pacotes que criam novas conexões
</li>
</ul>
<ul>
<li>
<samp>ESTABLISHED</samp> - Confere com conexões já estabelecidas
</li>
</ul>
<ul>
<li>
<samp>RELATED</samp> - Confere com pacotes relacionados indiretamente a uma
conexão, como mensagens de erro icmp, etc.
</li>
</ul>
<ul>
<li>
<samp>INVALID</samp> - Confere com pacotes que não puderam ser identificados
por algum motivo.  Como respostas de conexões desconhecidas.
</li>
</ul>

<p>
Caso seja necessário especificar mais de uma opções estas devem ser separadas
por vírgulas.

<pre>
     iptables -A INPUT -m state --state NEW -i ppp0 -j DROP
</pre>

<p>
Bloqueia qualquer tentativa de nova conexão vindo da interface ppp0.

<pre>
     iptables -A INPUT -m state --state NEW,INVALID -i ppp0 -j LOG
</pre>

<p>
Permite registrar novas conexões e pacotes inválidos vindos da interface ppp0.

<hr>

<a name="s-fw-iptables-mod-limit"></a>
<h3>10.6.2 Limitando o número de vezes que a regra confere</h3>

<p>
A opção <em>-m limit</em> permite especificar o número de vezes que uma regra
conferirá quando todas as outras condições forem satisfeitas.  O número padrão
de conferência é de 3 por hora, a não ser que seja modificado através dos
argumentos aceitos pelo <em>limit</em>:
<ul>
<li>
<samp>--limit num/tempo</samp> - Permite especificar a taxa de conferências do
limit.  O parâmetro <em>num</em> especifica um número e <em>tempo</em> pode ser
<ul>
<li>
<samp>s</samp> - Segundo
</li>
<li>
<samp>m</samp> - Minuto
</li>
<li>
<samp>h</samp> - Hora
</li>
<li>
<samp>d</samp> - Dia
</li>
</ul>

<p>
Assim uma regra como <samp>iptables -A INPUT -m limit --limit 5/m -j
ACCEPT</samp> permitirá que a regra acima confira apenas 5 vezes por minuto
(<em>--limit 2/s</em>).  Este limite pode ser facilmente adaptado para uma
regra de log que confere constantemente não causar uma avalanche em seus logs.
O valor padrão é 3/h.
</li>
</ul>
<ul>
<li>
<samp>--limit-burst num</samp> - Especifica o número inicial máximo de pacotes
que irão conferir, este número é aumentado por 1 a cada vez que o parâmetro
<em>--limit</em> acima não for atingido.  O valor padrão é 5.
</li>
</ul>

<hr>

<a name="s-fw-iptables-mod-limit-ping"></a>
<h3>10.6.3 Proteção contra ping da morte</h3>

<p>
A regra abaixo pode tomada como base para proteção contra ping flood:

<pre>
     iptables -t filter -A ping-chain -p icmp --icmp-type echo-request -m limit --limit 1/s -j ACCEPT
     iptables -t filter -A ping-chain -j DROP
</pre>

<p>
A regra acima limita em 1 vez por segundo (--limit 1/s) a passagem de pings
(echo requests) para a máquina <code>Linux</code>.

<pre>
     iptables -t filter -A ping-chain -i ppp0 -p icmp --icmp-type echo-reply -m limit --limit 1/s -j RETURN
     iptables -t filter -A ping-chain -j DROP
</pre>

<p>
Limita respostas a pings (echo reply) vindos da interface ppp0 (-i ppp0) a 1
por segundo.

<p>
<strong>ATENÇÃO:</strong> O exemplo acima é somente para a criação de suas
próprias regras com limitações, caso um pacote não confira ele será bloqueado
pela próxima regra.  Se uma regra como esta for colocada no chain INPUT sem
modificações, ela não terá o efeito desejado, podendo colocar em risco a sua
instalação pela falsa impressão de segurança.  Portanto, é recomendável sempre
testar as modificações para ter certeza que elas tem efeito.

<hr>

<a name="s-fw-iptables-mod-limit-synflood"></a>
<h3>10.6.4 Proteção contra syn flood</h3>

<p>
A regra abaixo é uma boa proteção para os ataques syn floods:

<pre>
     iptables -t filter -A syn-chain -p tcp --syn -m limit --limit 2/s -j ACCEPT
     iptables -t filter -A syn-chain -j DROP
</pre>

<p>
Esta regra limita o atendimento de requisições de conexões a 2 por segundo.
Outra forma de aumentar a segurança contra syn-floods é através do próprio
kernel ativando a opção &quot;TCP Synflood&quot; na compilação e depois
executando: <samp>echo &quot;1&quot;
&gt;/proc/sys/net/ipv4/tcp_synflood</samp>.  No entanto, utilize estas opções
com cautela em servidores que possuem um grande número de acessos para não ter
problemas que afetem seu clientes.

<p>
<strong>ATENÇÃO:</strong> Os exemplos acima devem são somente exemplos para
criação de suas próprias regras com limitações, caso um pacote não confira com
a regra ele será bloqueado pela próxima regra.  Se uma regra como esta for
colocada no chain INPUT sem modificações, ela não terá o efeito desejado,
podendo colocar em risco a sua instalação pela falsa impressão de segurança.
Portanto, é recomendável sempre testar as modificações para ter certeza que
elas tem efeito.

<hr>

<a name="s-fw-iptables-outras-ipspoof"></a>
<h3>10.6.5 Proteção contra IP spoofing</h3>

<p>
A especificação de endereços de origem/destino junto com a interface de rede
pode ser usado como um detector de ataques spoofing.  A lógica é que todos os
endereços que NUNCA devem vir da interface X devem ser negados imediatamente.
As regras abaixo são colocadas no inicio do chain INPUT para detectar tais
ataques:

<pre>
     iptables -A INPUT -s 192.168.1.0/24 -i ! eth0 -j DROP
     iptables -A INPUT ! -s 192.168.1.0/24 -i eth0 -j DROP
</pre>

<p>
A primeira regra diz para bloquear todos os endereços da faixa de rede
192.168.1.* que NÃO vem da interface eth0, a segunda regra diz para bloquear
todos os endereços que não sejam 192.168.1.* vindos da interface eth0.  O
símbolo &quot;!&quot; serve para especificar exceções (veja <a
href="#s-fw-iptables-outras-excessoes">Especificando uma exceção, Seção
10.3.5</a>.  O kernel do <code>Linux</code> automaticamente bloqueia a passagem
de pacotes que dizem ser de 127.0.0.1 e não está vindo da interface loopback.

<p>
O método preferido para controlar o ip spoofing é através do código de
roteamento do kernel (a não ser que esteja usando algum tipo de roteamento de
origem assimétrico necessário por alguns programas especiais):

<pre>
     for i in /proc/sys/net/ipv4/conf/*/rp_filter; do
      echo 1 &gt;$i
     done
</pre>

<p>
Desta forma qualquer endereço dizendo ser 192.168.1.5 vindo de
<code>ppp0</code> será imediatamente rejeitado.  Uma checagem adicional contra
IP spoofing pode ser feita no arquivo <code>/etc/host.conf</code> (veja <a
href="ch-rede.html#s-rede-dns-a-hostconf">/etc/host.conf, Seção 4.6.2.2</a>).

<hr>

<a name="s-fw-iptables-mod-multiport"></a>
<h3>10.6.6 Especificando múltiplas portas de origem/destino</h3>

<p>
O módulo <code>multiport</code> permite que seja especificado múltiplas portas
para um alvo.  Podem ser especificadas até 15 portas em um único parâmetro e
basta que uma porta confira para que a regra entre em ação, pois a comparação é
feita usando condições &quot;or&quot;.  O parâmetro <code>multiport</code> deve
ser acompanhado de um dos argumentos abaixo:
<ul>
<li>
<samp>--source-port [porta1, porta2...]</samp> - Faz a regra conferir se a
porta de origem estiver presente entre as portas especificadas.
</li>
<li>
<samp>--destination-port [porta1, porta2...]</samp> - Faz a regra conferir se a
porta de destino estiver presente entre as portas especificadas.
</li>
<li>
<samp>--port [porta1, porta2...]</samp> - Faz a regra conferir caso a porta de
origem ou destino esteja presente no parâmetro.
</li>
</ul>

<p>
Este módulo pode eliminar muitas regras de firewall que fazem o mesmo
tratamento de pacotes para diversas portas diferentes.

<pre>
     iptables -A INPUT -p tcp -i ppp0 -m multiport --destination-port 21,23,25,80,110,113,6667 -j DROP
</pre>

<p>
Bloqueia todos os pacotes vindo de ppp0 para as portas 21 (ftp), 23 (telnet),
25 (smtp), 80 (www), 110 (pop3), 113 (ident), 6667 (irc).

<hr>

<a name="s-fw-iptables-mod-mac"></a>
<h3>10.6.7 Especificando o endereço MAC da interface</h3>

<p>
O módulo <code>mac</code> serve para conferir com o endereço Ethernet dos
pacotes de origem.  Somente faz sentido se usado nos chains de PREROUTING (da
tabela nat) ou INPUT (da tabela filter).  Aceita como argumento a opção
<em>--mac-source endereço</em>.  O símbolo &quot;!&quot; pode ser usado para
especificar uma exceção.

<pre>
     iptables -t filter -A INPUT -m mac --mac-source 00:80:AD:B2:60:0B -j DROP
</pre>

<p>
Confere com a máquina com endereço ethernet igual a
<samp>00:80:AD:B2:60:0B</samp>.

<hr>

<a name="s-fw-iptables-mod-owner"></a>
<h3>10.6.8 Conferindo com quem criou o pacote</h3>

<p>
Este módulo confere com o usuário que iniciou a conexão.  É somente válido no
chain <em>OUTPUT</em> da tabela filter.  Os seguintes argumentos são válidas
para este módulo:
<ul>
<li>
<samp>--uid-owner UID</samp> - Confere se o pacote foi criado por um processo
com o UID especificado.  Até o momento somente UID numéricos são aceitos.
</li>
</ul>
<ul>
<li>
<samp>--gid-owner GID</samp> - Confere se o pacote foi criado por um usuário
pertencente ao grupo GID.  Até o momento somente GID numéricos são aceitos.
</li>
</ul>
<ul>
<li>
<samp>--pid-owner PID</samp> - Confere se o pacote foi criado por um processo
com o PID especificado.
</li>
</ul>
<ul>
<li>
<samp>--sid-owner ID</samp> - Confere se o pacote foi criado por um processo no
grupo de seção especificado.
</li>
</ul>

<p>
<strong>OBS:</strong> - Lembre-se que pacotes que não possuem detalhes
suficientes de cabeçalho nunca conferirão!

<pre>
     iptables -A OUTPUT -m owner --gid-owner 100 -p udp -j DROP
</pre>

<p>
Rejeita um conexões indo para portas UDP de pacotes criados pelo usuários
pertencentes ao grupo 100.

<hr>

<a name="s-fw-iptables-mod-string"></a>
<h3>10.6.9 Conferindo com o conteúdo do pacote</h3>

<p>
O módulo <code>string</code> do <code>iptables</code> permite a inspeção de
conteúdo de um pacote e tomar uma ação se determinado tipo de tráfego for
encontrado em um pacote.  Esta técnica pode ser usada tanto para segurança como
para economia de banda dentro da rede.  Esta opção *NÃO* torna o iptables como
um firewall proxy, pois o proxy tem a habilidade de inspecionar o conteúdo,
protocolo, comandos do pacote e decidir se o seu conteúdo é nocivo ou não.  O
firewall em nível de pacotes fazendo inspeção de conteúdo, chega a ser 3 a 10
vezes mais rápido do que um proxy, assim seu uso deve ser analisado dependendo
do tráfego que circula pelo link e da segurança dos dados que trafegam através
dele.

<p>
Uma boa prática é aliar esta opção a um IDS externo usando o alvo
<em>QUEUE</em> e deixando o trabalho de espeção de conteúdo para ele.  Um
exemplo de restrição direta é o bloqueio do envio de qualquer informação
confidencial sigilosa para fora da rede interna (número de contas, tudo que
conferir com CPF, CGC, endereços de e-mail, memorandos, etc).  De qualquer
forma, analise o tráfego de sua rede antes de querer implementar qualquer
solução baseada neste método sob o risco de afetar tráfego legítimo.

<p>
Outra utilidade eficiente é a diminuição de tráfego, pois podemos barrar
programas que sobrecarregam o link em uma rede com muitos usuários como, por
exemplo, usando o <code>Kazaa</code> ou qualquer outro programa para cópia de
arquivos via Internet.  Veja alguns exemplos:

<pre>
     # Bloqueia qualquer tentativa de acesso ao programa Kazaa
     iptables -A INPUT -m string --string &quot;X-Kazaa&quot; -j DROP
     
     # Não permite que dados confidenciais sejam enviados para fora da empresa
     # e registra o ocorrido.
     iptables -A OUTPUT -m string --string &quot;conta&quot; -j LOG --log-prefix &quot;ALERTA: dados confidencial &quot;
     iptables -A OUTPUT -m string --string &quot;conta&quot; -j DROP
     
     # Somente permite a passagem de pacotes que não contém &quot;.exe&quot; em seu conteúdo
     iptables -A INPUT -m string --string ! &quot;.exe&quot; -j ACCEPT
</pre>

<hr>

<a name="s-fw-iptables-mod-ttl"></a>
<h3>10.6.10 Conferindo com o tempo de vida do pacote</h3>

<p>
O módulo <code>ttl</code> pode ser usado junto com as seguintes opções para
conferir com o tempo de vida (TTL) de um pacote:
<ul>
<li>
<samp>--ttl-eq [num]</samp>
</li>
<li>
<samp>--ttl-lt [num]</samp>
</li>
<li>
<samp>--ttl-gq [num]</samp>
</li>
</ul>

<p>
Veja alguns exemplos:

<pre>
     # Confere com todos os pacotes que tem o TTL maior que 100
     iptables -A INPUT -m ttl --ttl-gt 100 -j LOG --log-prefix &quot;TTL alto&quot;
     
     # Confere com todos os pacotes que tem o TTL igual a 1
     iptables -A INPUT -m ttl --ttl-eq 1 -j DROP
</pre>

<p>
<strong>OBS:</strong> Tenha um especial cuidado durante a programação de regras
que usem TTL, como elas estão especialmente associadas com o estado da
comunicação estabelecida entre as duas pontas e o tipo de protocolo, cuidados
especiais devem ser tomados para que seu firewall não manipule de forma
incorreta tráfego válido.

<hr>

<a name="s-fw-iptables-mod-rpc"></a>
<h3>10.6.11 Conferindo com números RPC</h3>

<p>
O módulo <code>rpc</code> permite um controle especial sobre o tráfego RPC que
chega até a sua máquina.  Um uso útil é restringir a chamada a determinados
números RPC e permitir outros (por exemplo, permitindo somente o serviço
<em>keyserv</em> e bloqueando outros como o <em>ypserv</em> ou
<em>portmapper</em>).  As seguintes opções podem ser usadas com o módulo
<code>nfs</code>:
<ul>
<li>
<samp>--rpcs [procedimentos]</samp> - Confere com a lista de chamadas RPC
especificadas.  Mais de um procedimento RPC pode ser especificado como
<samp>nome</samp> ou <samp>número</samp> separando-os com vírgulas.  Um arquivo
útil que contém esta lista é o <code>/etc/rpc</code>.
</li>
<li>
<samp>--strict</samp> - Ignora serviços RPC que não contenham a chamada
<em>get</em> do portmapper.  Em situações normais, o inicio de qualquer
solicitação RPC.
</li>
</ul>

<p>
Veja alguns exemplos:

<pre>
     # Para conferir com todas as chamadas RPC referentes a conexões iniciadas
     # para o portmapper
     iptables -A INPUT -m rpc --rpcs portmapper --strict -j DROP
     
     # Para permitir que somente as chamadas para status e statmon sejam
     # aceitas
     iptables -A INPUT -m rpc --rpcs 100023,100024 -j ACCEPT
</pre>

<hr>

<a name="s-fw-iptables-mod-pkttype"></a>
<h3>10.6.12 Conferindo com tipo de pacote</h3>

<p>
O módulo <code>pkttype</code> permite identificar um pacote do tipo
<em>unicast</em> (direcionado a você), <em>broadcast</em> (direcionado a uma
determinada rede, definida pela netmask) ou <em>multicast</em> (destinado a
grupos de redes) e desta forma realizar ações em cima destes.  O tipo de pacote
é identificado logo após a opção <em>--pkt-type</em>.  Veja alguns exemplos:

<pre>
     # Bloqueia a passagem de pacotes multicast de uma rede para outra
     iptables -A FORWARD -i eth0 -o eth0 -m pkttype --pkt-type multicast -j DROP 
     
     # Como deve ter notado, é possível fazer a associação com diversas especificações
     # de módulos, bastando apenas especificar uma opção &quot;-m&quot; para cada módulo
     # adicional:
     # Permite a passagem de pacotes broadcast de uma rede para outra com
     # limitação de 5/s.
     iptables -A FORWARD -i eth0 -o eth0 -m pkttype --pkt-type broadcast -m limit --limit 5/s -j ACCEPT
</pre>

<hr>

<a name="s-fw-iptables-mod-length"></a>
<h3>10.6.13 Conferindo com o tamanho do pacote</h3>

<p>
O tamanho do pacote pode ser usado como condição de filtragem através do módulo
<code>length</code>.  O tamanho do pacote é especificado através da opção
<em>--length</em> e o argumento segue a mesma sintaxe da especificação de
portas no <code>iptables</code> sendo separados por <em>:</em>.  Veja alguns
exemplos:

<pre>
     # Bloqueia qualquer pacote ICMP maior que 30Kb
     iptables -A INPUT -i eth0 -m length --length 30000: -j DROP
     
     # Bloqueia qualquer pacote com o tamanho entre 20 e 2000 bytes
     iptables -A INPUT -i eth0 -m length --length 20:2000 -j DROP
</pre>

<hr>

<a name="s-fw-iptables-path"></a>
<h2>10.7 Caminho percorrido pelos pacotes nas tabelas e chains</h2>

<p>
É MUITO importante entender a função de cada filtro e a ordem de acesso dos
chains de acordo com o tipo de conexão e interface de origem/destino.  Esta
seção explica a ordem que as regra são atravessadas, isso lhe permitirá
planejar a distribuição das regras nos chains, e evitar erros de localização de
regras que poderia deixar seu firewall com sérios problemas de segurança, ou um
sistema de firewall totalmente confuso e sem lógica.

<p>
Nos exemplos abaixo assumirei a seguinte configuração:
<ul>
<li>
A máquina do firewall com <code>iptables</code> possui o endereço IP
<code>192.168.1.1</code> e conecta a rede interna ligada via interface
<code>eth0</code> a internet via a interface <code>ppp0</code>.
</li>
<li>
Rede interna com a faixa de endereços <code>192.168.1.0</code> conectada ao
firewall via interface <code>eth0</code>
</li>
<li>
Interface <code>ppp0</code> fazendo conexão com a Internet com o endereço IP
<code>200.217.29.67</code>.
</li>
<li>
A conexão das máquinas da rede interna (<code>eth0</code>) com a rede externa
(<code>ppp0</code>) é feita via <em>Masquerading</em>.
</li>
</ul>

<p>
Também utilizarei a sintaxe <em>CHAIN-tabela</em> para fazer referência aos
chains e tabelas dos blocos ASCII: <em>INPUT-filter</em> - chain <em>INPUT</em>
da tabela <em>filter</em>.

<p>
<strong>ATENÇÃO:</strong> A ordem de processamento das regras do
<code>iptables</code>, é diferente do <code>ipchains</code> devido a inclusão
do novo sistema de nat e da tabela mangle.

<hr>

<a name="s-fw-iptables-path-PingICMPLocal-Local"></a>
<h3>10.7.1 Ping de 192.168.1.1 para 192.168.1.1</h3>

<ul>
<li>
Endereço de Origem: <samp>192.168.1.1</samp>
</li>
<li>
Endereço de Destino: <samp>192.168.1.1</samp>
</li>
<li>
Interface de Entrada: <samp>lo</samp>
</li>
<li>
Interface de Saída: <samp>lo</samp>
</li>
<li>
Protocolo: <samp>ICMP</samp>
</li>
<li>
Descrição: <samp>Ping para o próprio firewall</samp>
</li>
</ul>

<pre>
     SAÍDA DE PACOTES (envio do ping para 192.168.1.1): 
     +-------------+    +----------+    +-------------+   +------------------+  +----------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-nat| =&gt; |OUTPUT-filter| =&gt;|POSTROUTING-mangle|=&gt;|POSTROUTING-nat |
     +-------------+    +----------+    +-------------+   +------------------+  +----------------+
     
     ENTRADA DOS PACOTES (Retorno da resposta ping acima): 
     +-----------------+   +------------+  +------------+
     |PREROUTING-mangle| =&gt;|INPUT-mangle|=&gt;|INPUT-filter|
     +-----------------+   +------------+  +------------+
</pre>

<p>
Quando damos o ping (<em>echo request</em>) os pacotes seguem o caminho em
<em>SAÍDA DE PACOTES</em> percorrendo os chains na ordem especificada e
retornam via <em>ENTRADA DOS PACOTES</em> (<em>echo reply</em>).  No envio da
resposta da requisição de ping, o caminho de saída do pacote ignora os chains
OUTPUT-nat e POSTROUTING-nat (já que não é necessário nat) mas sempre processa
os chains correspondentes da tabela mangle na ordem indicada acima.

<p>
<strong>OBS1:</strong> Para conexões com destinos na própria máquina usando um
endereço IP das interfaces locais, a interface será ajustada sempre para
<code>lo</code> (loopback).

<p>
<strong>OBS2:</strong> Em qualquer operação de entrada/saída de pacotes, os
dois chains da tabela <em>mangle</em> são sempre os primeiros a serem
acessados.  Isto é necessário para definir a prioridade e controlar outros
aspectos especiais dos pacotes que atravessam os filtros.

<p>
<strong>OBS3:</strong> O chain <em>OUTPUT</em> da tabela <em>filter</em> é
consultado sempre quando existem conexões se originando em endereços de
interfaces locais.

<hr>

<a name="s-fw-iptables-path-FtpTCPLocal-Local"></a>
<h3>10.7.2 Conexão FTP de 192.168.1.1 para 192.168.1.1</h3>

<ul>
<li>
Endereço de Origem: <samp>192.168.1.1</samp>
</li>
<li>
Endereço de Destino: <samp>192.168.1.1</samp>
</li>
<li>
Interface de Origem: <samp>lo</samp>
</li>
<li>
Interface de Destino: <samp>lo</samp>
</li>
<li>
Porta Origem: <samp>1404</samp>
</li>
<li>
Porta Destino: <samp>21</samp>
</li>
<li>
Protocolo: <samp>TCP</samp>
</li>
<li>
Descrição: <samp>Conexão ftp (até o prompt de login, sem transferência de
arquivos).</samp>
</li>
</ul>

<pre>
     SAÍDA DOS PACOTES (envio da requisição para 192.168.1.1): 
     +-------------+    +----------+    +-------------+    +------------------+    +---------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-nat| =&gt; |OUTPUT-filter| =&gt; +POSTROUTING-mangle| =&gt; |POSTROUTING-nat|
     +-------------+    +----------+    +-------------+    +------------------+    +---------------+
     
     ENTRADA DE PACOTES (respostas da requisição vindas de 192.168.1.1): 
     +-----------------+    +------------+    +------------+
     |PREROUTING-mangle| =&gt; |INPUT-mangle| =&gt; |INPUT-filter|
     +-----------------+    +------------+    +------------+
</pre>

<p>
A requisição ftp passa através dos chains especificados em <em>SAÍDA DOS
PACOTES</em> e retorna por <em>ENTRADA DE PACOTES</em>.  Após a conexão ser
estabelecida, o caminho de <em>SAÍDA DE PACOTES</em> será:

<pre>
     +-------------+    +-------------+    +------------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-filter| =&gt; |POSTROUTING-mangle|
     +-------------+    +-------------+    +------------------+
</pre>

<p>
pois os dados de entrada que vem da interface externa, são passados diretamente
a máquina do firewall, não necessitando de tratamento SNAT (os chains
<em>OUTPUT-nat</em> e <em>POSTROUTING-nat</em> são processado somente uma vez a
procura de regras que conferem, principalmente para fazer SNAT).  Note
novamente que mesmo não sendo necessário NAT, o chain POSTROUTING-mangle é
checado.

<p>
<strong>OBS1:</strong> Para conexões com destinos na própria máquina usando um
endereço IP das interfaces locais, a interface será ajustada sempre para
<code>lo</code> (loopback).

<p>
<strong>OBS2:</strong> Em qualquer operação de entrada/saída de pacotes, os
dois chains da tabela mangle são sempre os primeiros a serem acessados.  Isto é
necessário para definir a prioridade e controlar outros aspectos especiais dos
pacotes que atravessam os filtros.

<hr>

<a name="s-fw-iptables-path-FtpTCPLocal-LocalNet"></a>
<h3>10.7.3 Conexão FTP de 192.168.1.1 para 192.168.1.4</h3>

<ul>
<li>
Endereço de Origem: <samp>192.168.1.1</samp>
</li>
<li>
Endereço de Destino: <samp>192.168.1.4</samp>
</li>
<li>
Interface de Origem: <samp>eth0</samp>
</li>
<li>
Interface de Destino: <samp>eth0</samp>
</li>
<li>
Porta Origem: <samp>1405</samp>
</li>
<li>
Porta Destino: <samp>21</samp>
</li>
<li>
Protocolo: <samp>TCP</samp>
</li>
<li>
Descrição: <samp>Conexão ftp (até o prompt de login, sem transferência de
arquivos).</samp>
</li>
</ul>

<pre>
     SAÍDA DOS PACOTES (envio da requisição para 192.168.1.4): 
     +-------------+    +----------+    +-------------+    +------------------+    +---------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-nat| =&gt; |OUTPUT-filter| =&gt; +POSTROUTING-mangle| =&gt; |POSTROUTING-nat|
     +-------------+    +----------+    +-------------+    +------------------+    +---------------+
     
     ENTRADA DE PACOTES (respostas da requisição de 192.168.1.4): 
     +-----------------+    +------------+    +------------+
     |PREROUTING-mangle| =&gt; |INPUT-mangle| =&gt; |INPUT-filter|
     +-----------------+    +------------+    +------------+
</pre>

<p>
A requisição ftp passa através dos chains especificados em <em>SAÍDA DOS
PACOTES</em> com o destino <code>192.168.1.4</code> porta <code>21</code> e
retorna por <em>ENTRADA DE PACOTES</em> para <code>192.168.1.1</code> porta
<code>1405</code>.  Após a conexão ser estabelecida, o caminho de <em>SAÍDA DE
PACOTES</em> será:

<pre>
     +-------------+    +-------------+    +------------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-filter| =&gt; |POSTROUTING-mangle|
     +-------------+    +-------------+    +------------------+
</pre>

<p>
pois os dados não precisam de tratamento SNAT (os chains <em>OUTPUT-nat</em> e
<em>POSTROUTING-nat</em> são processado somente uma vez a procura de regras que
conferem, principalmente para fazer SNAT).

<p>
<strong>OBS:</strong> Em qualquer operação de entrada/saída de pacotes, os dois
chains da tabela mangle são sempre os primeiros a serem acessados.  Isto é
necessário para definir a prioridade e controlar outros aspectos especiais dos
pacotes que atravessam os filtros.

<hr>

<a name="s-fw-iptables-path-FtpTCPLocal-RemoteNet"></a>
<h3>10.7.4 Conexão FTP de 200.217.29.67 para a máquina ftp.debian.org.br</h3>

<ul>
<li>
Endereço de Origem: <samp>200.217.29.67</samp>
</li>
<li>
Endereço de Destino: <samp>200.198.129.162</samp>
</li>
<li>
Interface de Origem: <samp>ppp0</samp>
</li>
<li>
Interface de Destino: <samp>ppp0</samp>
</li>
<li>
Porta Origem: <samp>1407</samp>
</li>
<li>
Porta Destino: <samp>21</samp>
</li>
<li>
Protocolo: <samp>TCP</samp>
</li>
<li>
Descrição: <samp>Conexão ftp (até o prompt de login, sem transferência de
arquivos).</samp>
</li>
</ul>

<pre>
     SAÍDA DOS PACOTES (envio da requisição para 200.198.129.162): 
     +-------------+    +----------+    +-------------+    +------------------+    +---------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-nat| =&gt; |OUTPUT-filter| =&gt; +POSTROUTING-mangle| =&gt; |POSTROUTING-nat|
     +-------------+    +----------+    +-------------+    +------------------+    +---------------+
     
     ENTRADA DE PACOTES (respostas da requisição vindas de 200.198.129.162): 
     +-----------------+    +------------+    +------------+
     |PREROUTING-mangle| =&gt; |INPUT-mangle| =&gt; |INPUT-filter|
     +-----------------+    +------------+    +------------+
</pre>

<p>
A requisição ftp passa através dos chains especificados em <em>SAÍDA DOS
PACOTES</em> com o destino <code>200.198.129.162</code> porta <code>21</code>
(após a resolução DNS de <code>www.debian.org.br</code>) e retorna por
<em>ENTRADA DE PACOTES</em> para <code>200.217.29.67</code> porta
<code>1407</code>.  Após a conexão ser estabelecida, o caminho de saída de
pacotes é:

<pre>
     +-------------+    +-------------+    +------------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-filter| =&gt; |POSTROUTING-mangle|
     +-------------+    +-------------+    +------------------+
</pre>

<p>
pois os dados não precisam de tratamento SNAT (os chains <em>OUTPUT-nat</em> e
<em>POSTROUTING-nat</em> são processado somente uma vez a procura de regras que
conferem, principalmente para fazer SNAT).

<p>
E após a conexão estabelecida, o caminho de entrada de pacotes passa a ser:

<pre>
     +-----------------+    +------------+    +------------+
     |PREROUTING-mangle| =&gt; |INPUT-mangle| =&gt; |INPUT-filter|
     +-----------------+    +------------+    +------------+
</pre>

<p>
pois os dados não precisam de tratamento DNAT (o chain <em>PREROUTING-nat</em>
é processado somente uma vez a procura de regras que conferem, principalmente
para fazer DNAT).

<p>
<strong>OBS:</strong> Para qualquer operação de entrada/saída de pacotes, os
dois chains da tabela mangle são sempre os primeiros a serem acessados.  Isto é
necessário para definir a prioridade e controlar outros aspectos especiais dos
pacotes que atravessam os filtros.

<hr>

<a name="s-fw-iptables-path-PingICMPLocalNet-Local"></a>
<h3>10.7.5 Ping de 192.168.1.4 para 192.168.1.1</h3>

<ul>
<li>
Endereço de Origem: <samp>192.168.1.4</samp>
</li>
<li>
Endereço de Destino: <samp>192.168.1.1</samp>
</li>
<li>
Interface de Entrada: <samp>eth0</samp>
</li>
<li>
Interface de Saída: <samp>eth0</samp>
</li>
<li>
Protocolo: <samp>ICMP</samp>
</li>
<li>
Descrição: <samp>Ping de 192.168.1.4 para a máquina do firewall.</samp>
</li>
</ul>

<pre>
     ENTRADA DE PACOTES (recebimento da requisição, vinda de 192.168.1.4): 
     +-----------------+    +--------------+    +------------+    +------------+
     |PREROUTING-mangle| =&gt; |PREROUTING-nat| =&gt; |INPUT-mangle| =&gt; |INPUT-filter|
     +-----------------+    +--------------+    +------------+    +------------+
     
     SAÍDA DE PACOTES (envio da resposta a 192.168.1.4)
     +-------------+    +-------------+    +------------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-filter| =&gt; |POSTROUTING-mangle|
     +-------------+    +-------------+    +------------------+
</pre>

<p>
Quando damos o ping (<em>echo request</em>) os pacotes seguem o caminho em
<em>ENTRADA DE PACOTES</em> percorrendo os chains na ordem especificada e
retornam via <em>SAÍDA DOS PACOTES</em> (<em>echo reply</em>).

<p>
<strong>OBS1:</strong> Para qualquer operação de entrada/saída de pacotes, os
dois chains da tabela mangle são sempre os primeiros a serem acessados.  Isto é
necessário para definir a prioridade e controlar outros aspectos especiais dos
pacotes que atravessam os filtros.

<hr>

<a name="s-fw-iptables-path-FtpTCPLocalNet-Local"></a>
<h3>10.7.6 Conexão FTP de 192.168.1.4 para 192.168.1.1</h3>

<ul>
<li>
Endereço de Origem: <samp>192.168.1.4</samp>
</li>
<li>
Endereço de Destino: <samp>192.168.1.1</samp>
</li>
<li>
Interface de Origem: <samp>eth0</samp>
</li>
<li>
Interface de Destino: <samp>eth0</samp>
</li>
<li>
Porta Origem: <samp>1030</samp>
</li>
<li>
Porta Destino: <samp>21</samp>
</li>
<li>
Protocolo: <samp>TCP</samp>
</li>
<li>
Descrição: <samp>Conexão ftp (até o prompt de login, sem transferência de
dados).</samp>
</li>
</ul>

<pre>
     ENTRADA DOS PACOTES (envio da requisição vindas de 192.168.1.4): 
     +-----------------+    +--------------+    +------------+    +------------+
     |PREROUTING-mangle| =&gt; |PREROUTING-nat| =&gt; |INPUT-mangle| =&gt; |INPUT-filter|
     +-----------------+    +--------------+    +------------+    +------------+
     
     SAÍDA DE PACOTES (respostas da requisição acima para 192.168.1.4): 
     +-------------+    +-------------+    +------------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-filter| =&gt; |POSTROUTING-mangle|
     +-------------+    +-------------+    +------------------+
</pre>

<p>
A requisição ftp passa através dos chains especificados em <em>ENTRADA DOS
PACOTES</em> com o destino <code>192.168.1.1</code> porta <code>21</code> e
retorna por <em>SAÍDA DE PACOTES</em> para <code>192.168.1.4</code> porta
<code>1030</code>.  Após a conexão ser estabelecida, o caminho de entrada de
pacotes é:

<pre>
     +-----------------+    +------------+    +------------+
     |PREROUTING-mangle| =&gt; |INPUT-mangle| =&gt; |INPUT-filter|
     +-----------------+    +------------+    +------------+
</pre>

<p>
pois os dados não precisam de tratamento DNAT (o chain <em>PREROUTING-nat</em>
é processado somente uma vez a procura de regras que conferem, principalmente
para fazer DNAT).

<p>
<strong>OBS:</strong> O roteamento é sempre realizado após o processamento do
chain <em>PREROUTING</em> da tabela <em>nat</em>.

<hr>

<a name="s-fw-iptables-path-FtpTCPLocalNet-RemoteNet"></a>
<h3>10.7.7 Conexão FTP de 192.168.1.4 para ftp.debian.org.br</h3>

<ul>
<li>
Endereço de Origem: <samp>192.168.1.4</samp>
</li>
<li>
Endereço de Destino: <samp>200.198.129.162</samp>
</li>
<li>
Interface de Origem: <samp>eth0</samp>
</li>
<li>
Interface de Destino: <samp>ppp0</samp>
</li>
<li>
Porta Origem: <samp>1032</samp>
</li>
<li>
Porta Destino: <samp>21</samp>
</li>
<li>
Protocolo: <samp>TCP</samp>
</li>
<li>
Descrição: <samp>Conexão ftp (até o prompt de login, sem transferência de
dados).</samp>
</li>
</ul>

<pre>
     SAÍDA DOS PACOTES (requisição vindas de 192.168.1.4): 
     +-----------------+    +--------------+    +--------------+   
     |PREROUTING-mangle| =&gt; |PREROUTING-nat| =&gt; |FORWARD-mangle| =&gt; (continua abaixo)
     +-----------------+    +--------------+    +--------------+   
     +--------------+    +------------------+    +---------------+
     |FORWARD-filter| =&gt; |POSTROUTING-mangle| =&gt; |POSTROUTING-nat|
     +--------------+    +------------------+    +---------------+
     
     ENTRADA DE PACOTES (respostas da requisição acima, enviadas para 192.168.1.4): 
     +-----------------+    +--------------+    +--------------+    +------------------+
     |PREROUTING-mangle| =&gt; |FORWARD-mangle| =&gt; |FORWARD-filter| =&gt; |POSTROUTING-mangle|
     +-----------------+    +--------------+    +--------------+    +------------------+
</pre>

<p>
A requisição ftp passa através dos chains especificados em <em>SAÍDA DOS
PACOTES</em> com o destino <code>200.198.129.162</code> porta <code>21</code>
(após a resolução DNS de <code>ftp.debian.org.br</code>) e retorna por
<em>ENTRADA DE PACOTES</em> para <code>192.168.1.4</code> porta
<code>1032</code>.

<p>
Note que o Masquerading regrava os pacotes; para a máquina
<code>200.198.129.162</code> a conexão está sendo feita para
<code>200.217.29.67</code>.  As respostas de conexões vindas de
<code>200.198.129.162</code> e indo para <code>200.217.29.67</code> são
regravadas no firewall com o destino <code>192.168.1.4</code> e enviadas para a
máquina correspondente.  Após a conexão ser estabelecida, o caminho de saída de
pacotes para 200.198.129.163 é:

<pre>
     +-----------------+    +--------------+    +--------------+    +------------------+
     |PREROUTING-mangle| =&gt; |FORWARD-mangle| =&gt; |FORWARD-filter| =&gt; |POSTROUTING-mangle|
     +-----------------+    +--------------+    +--------------+    +------------------+
</pre>

<p>
Após a conexão estabelecida, o caminho da entrada de pacotes vindos de
200.198.129.163 é:

<pre>
     +-----------------+    +--------------+    +--------------+    +------------------+
     |PREROUTING-mangle| =&gt; |FORWARD-mangle| =&gt; |FORWARD-filter| =&gt; |POSTROUTING-mangle|
     +-----------------+    +--------------+    +--------------+    +------------------+
</pre>

<p>
Isto acontece porque após feita a conexão Masquerading (via PREROUTING-nat), o
firewall já sabe como reescrever os pacotes para realizar a operação de
Masquerading, reescrevendo todos os pacotes que chegam de
<code>www.debian.org.br</code> para <code>192.168.1.4</code>.

<p>
<strong>OBS:</strong> As conexões Masquerading feitas através da rede interna,
são enviadas para <code>200.198.129.162</code> tem o endereço de origem
ajustado para <code>200.217.29.67</code> que é o IP de nossa interface
<code>ppp0</code>.  Quando as respostas atravessam o firewall, os pacotes são
checados pra saber se são uma resposta a uma conexão masquerading e fará a
regravação dos pacotes substituindo o endereço de destino para
<code>192.168.1.4</code>.  Caso uma operação de Masquerading falhe, os pacotes
serão Bloqueados.

<hr>

<a name="s-fw-iptables-path-FtpTCPRemoteNet-Local"></a>
<h3>10.7.8 Conexão FTP de 200.198.129.162 para 200.217.29.167</h3>

<ul>
<li>
Endereço de Origem: <samp>200.198.129.162</samp>
</li>
<li>
Endereço de Destino: <samp>200.217.29.67</samp>
</li>
<li>
Interface de Origem: <samp>ppp0</samp>
</li>
<li>
Interface de Destino: <samp>ppp0</samp>
</li>
<li>
Porta Origem: <samp>3716</samp>
</li>
<li>
Porta Destino: <samp>21</samp>
</li>
<li>
Protocolo: <samp>TCP</samp>
</li>
<li>
Descrição: <samp>Conexão ao serviço ftp do firewall</samp>
</li>
</ul>

<pre>
     ENTRADA DOS PACOTES (requisição vinda de 200.198.129.162): 
     +-----------------+    +--------------+    +-------------+    +------------+
     |PREROUTING-mangle| =&gt; |PREROUTING-nat| =&gt; |INPUT-mangle | =&gt; |INPUT-filter|
     +-----------------+    +--------------+    +-------------+    +------------+
     
     SAÍDA DE PACOTES (respostas da requisição de 200.198.129.162): 
     +-------------+    +-------------+    +------------------+
     |OUTPUT-mangle| =&gt; |OUTPUT-filter| =&gt; |POSTROUTING-mangle|
     +-------------+    +-------------+    +------------------+
</pre>

<p>
A requisição ftp passa através dos chains especificados em <em>ENTRADA DOS
PACOTES</em> com o destino <code>200.217.29.67</code> (nossa interface
<code>ppp0</code> local) porta <code>21</code> e retorna por <em>SAÍDA DE
PACOTES</em> para <code>200.198.129.162</code> porta <code>3716</code> (também
via <code>ppp0</code>).  Após a conexão ser estabelecida, o caminho de entrada
de pacotes é:

<pre>
     +-----------------+    +------------+    +------------+
     |PREROUTING-mangle| =&gt; |INPUT-mangle| =&gt; |INPUT-filter|
     +-----------------+    +------------+    +------------+
</pre>

<p>
Isto acontece porque após feita a análise do chain <em>PREROUTING</em> (para
necessidade de DNAT), a máquina já saberá tomar a decisão apropriada para
gerenciar aquela conexão.

<hr>

<a name="s-fw-iptables-path-grafico"></a>
<h3>10.7.9 Gráfico geral da passagem dos pacotes</h3>

<p>
Este gráfico foi retirado do documento <code>netfilter-hacking-HOWTO.txt</code>
e mostra a estrutura geral de passagem dos pacotes nas tabelas/chains.  Os
exemplos de passagem de pacotes acima poderão ser facilmente comparados com as
etapas abaixo para compreender a estrutura do <code>iptables</code>.

<pre>
     E ---&gt; PREROUTING ------&gt; (ROTEAM.) ---&gt; FORWARD ----------&gt; POSTROUTING --&gt; S
            Mangle e              |           Mangle       ^      Mangle
            NAT (DNAT))           |           Filter       |      NAT (SRC)
                                  |                     (ROTEAM.)
                                  v                        |
                                  IN Mangle,              OUT - Mangle,
                                  |  Filter                ^    NAT (DNAT)
                                  |                        |    Filter
                                  v                        |  
                         +----------------------------------------+
                         |            Processo Local              |
                         +----------------------------------------+
</pre>

<hr>

<a name="s-fw-iptables-exemplo"></a>
<h2>10.8 Exemplos de configurações do iptables</h2>

<p>
Exemplo de como bloquear todas as conexões para a máquina do firewall
permitindo somente conexões da máquina Linux para fora.

<hr>

<a name="s-fw-iptables-exemplo-bloqueio"></a>
<h3>10.8.1 Bloqueando conexões de fora para sua máquina</h3>

<p>
As regras a seguir servem para bloquear tentativas de conexões da interface de
Internet (ppp0) a sua rede sem bloquear o tráfego de conexões já iniciadas.  O
tráfego de outras interfaces não é afetado com as regras a seguir:

<pre>
     iptables -A INPUT -i ppp0 -m state --state ! ESTABLISHED,RELATED -j DROP
</pre>

<p>
Todas as conexões vindas de ppp0 de estado diferente de ESTABLISHED e RELATED
(NEW e INVALID) serão derrubadas.  Veja <a
href="#s-fw-iptables-mod-state">Conferindo de acordo com o estado da conexão,
Seção 10.6.1</a> para detalhes.

<pre>
     iptables -A INPUT -i ppp0 --syn -j DROP
</pre>

<p>
Este acima é mais simples e possui o mesmo efeito: Pacotes SYN são usados para
iniciar conexões, derrubando pacotes deste tipo significa bloquear novas
conexões.  Pacotes de conexões já estabelecidas ainda são permitidos.

<p>
Estas regras acima servem para quem não deseja NENHUM acesso indevido a sua
máquina.  Existem outras formas de bloquear conexões de modo mais seletivo
usando chains específicos, endereços de origem/destino, portas, etc., este tipo
de configuração é muito usada caso precise fornecer algum tipo de serviço que
seja acessível externamente e protegendo outros.

<hr>

<a name="s-fw-iptables-exemplo-trojans"></a>
<h3>10.8.2 Monitorando tentativa de conexão de trojans em sua máquina</h3>

<p>
As regras abaixo alertam sobre a tentativa de conexão dos trojans &quot;For
Win&quot; mais conhecidos.  Coloquei isto aqui por curiosidade de algumas
pessoas, pois máquinas <code>Linux</code> são imunes a este tipo de coisa:

<pre>
     #!/bin/sh
     
     TROJAN_PORTS=&quot;12345 31336 31337 31338 3024 4092 5714 5742 2583 8787 5556 5557&quot;
     
     iptables -t filter -N trojans-in
     
     for PORTA in ${TROJAN_PORTS};do
      iptables -A trojans-in -p tcp --sport=1024: --dport=${PORTA} -j LOG \
               --log-prefix &quot;FIREWALL: Trojan ${PORTA} &quot;
      iptables -A trojans-in -p tcp --sport=1024: --dport=${PORTA} -j DROP
     done
     
     iptables -t filter -A INPUT -i ppp0 -j trojans-in
</pre>

<p>
A primeira linha do <code>iptables</code> cria o chain <em>trojans-in</em>
dentro da tabela <em>filter</em> que usaremos para armazenar nossas regras de
firewall.  A segunda (dentro do laço for) faz uma regra de LOG para registrar
as tentativas de acesso de trojans em nosso sistema, a terceira rejeita o
acesso.  A quarta regra do <code>iptables</code> cria de todo o tráfego vindo
da interface ppp0 pra o chain trojans-in (queremos que só o tráfego vindo da
internet seja analisado pelo chain <em>trojans-in</em>).

<p>
Muitas das portas especificadas na variável <var>TROJAN_PORTS</var> são antigas
conhecidas de quem já brincou ou sofreram com o <code>Back Orifice</code>,
<code>Win Crack</code>, <code>NetBus</code> (quem nunca passou pela fase de ter
uma lista com mais de 100 netmasks e conseguir encontrar centenas de máquinas
por dia infectadas pelo BO?  :-).

<p>
No código acima a única coisa que precisa fazer para adicionar mais portas é
inseri-las na variável <var>TROJAN_PORTS</var> e executar o programa.  O laço
do <samp>for</samp> executará as 2 regras para cada porta processada
(economizando linhas e linhas de regras, me livrando de uma LER e poupando
muitos bytes neste guia ;-).

<p>
Dependendo do número de portas alvo, este código pode ser muito simplificado
usando o recurso multiport do <code>iptables</code> (veja <a
href="#s-fw-iptables-mod-multiport">Especificando múltiplas portas de
origem/destino, Seção 10.6.6</a> para detalhes).

<hr>

<a name="s-fw-iptables-exemplo-snat"></a>
<h3>10.8.3 Conectando sua rede interna a Internet</h3>

<p>
O seguinte exemplo permite ligar sua rede interna com a faixa de IP's
<code>192.168.1.*</code> a internet (usando uma conexão discada do tipo ppp):

<pre>
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -j MASQUERADE
     echo &quot;1&quot; &gt;/proc/sys/net/ipv4/ip_forward
</pre>

<hr>

<a name="s-fw-iptables-exemplo-fw"></a>
<h3>10.8.4 Um exemplo de firewall simples</h3>

<p>
Esta seção possui um exemplo mais elaborado de firewall que servirá para
máquinas conectadas via ppp com uma rede interna conectada via Masquerading.
Este exemplo não é tão complexo e cobre as expectativas mais comuns de pessoas
que gostam de explorar os potenciais de rede no <code>Linux</code> ou
satisfazer sua curiosidade.  Ele poderá ser facilmente adaptado para atender
outro tipo de necessidade.  A configuração assumida é a seguinte:
<ol type="1" start="1" >
<li>
Máquina do firewall com 2 interfaces de rede, uma é <code>eth0</code> com o IP
<code>192.168.1.1</code> que serve de ligação a sua rede Interna, a outra é
<code>ppp0</code> que é a interface Internet.
</li>
<li>
Qualquer acesso externo a máquinas da rede interna é bloqueado.
</li>
<li>
Os usuários da rede local tem acesso livre ao servidor <code>Linux</code>.
</li>
<li>
Qualquer acesso externo a máquina do firewall é bloqueado, exceto conexões para
o serviço <code>Apache</code> (<samp>httpd</samp>).  Outras tentativas de
conexões devem ser explicitamente registradas nos logs do sistema para
conhecimento do administrador.
</li>
<li>
Todos os usuários possuem acesso livre a Internet via Masquerading, exceto que
o acesso para o serviço www deve ser obrigatoriamente feito via
<code>squid</code>, e o servidor smtp a ser usado deverá ser o do firewall
<code>Linux</code>.
</li>
<li>
Prioridades serão estabelecidas para os serviços de telnet, IRC,talk e DNS.
</li>
</ol>

<pre>
     #!/bin/sh
     # Modelo de configuração de firewall
     # Autor: Gleydson M. Silva
     # Data: 05/09/2001
     # Descrição: Produzido para ser distribuído livremente, acompanha o guia 
     #             Foca GNU/Linux. http://www.guiafoca.org
     #
     
     # É assumido um sistema usando kmod para carga automática dos módulos usados por
     # esta configuração do firewall:
     # ipt_filter
     # ipt_nat
     # ipt_conntrack
     # ipt_mangle
     # ipt_TOS
     # ipt_MASQUERADE
     # ipt_LOG
     
     # Se você tem um kernel modularizado que não utiliza o kmod, será necessário 
     # carregar estes módulos via modprobe, insmod ou iptables --modprobe=modulo
     
     ##### Definição de Policiamento #####
     # Tabela filter
     iptables -t filter -P INPUT DROP
     iptables -t filter -P OUTPUT ACCEPT
     iptables -t filter -P FORWARD DROP
     # Tabela nat
     iptables -t nat -P PREROUTING ACCEPT
     iptables -t nat -P OUTPUT ACCEPT
     iptables -t nat -P POSTROUTING DROP
     # Tabela mangle
     iptables -t mangle -P PREROUTING ACCEPT
     iptables -t mangle -P OUTPUT ACCEPT
     
     
     ##### Proteção contra IP Spoofing #####
     for i in /proc/sys/net/ipv4/conf/*/rp_filter; do
      echo 1 &gt;$i
     done
     
     ##### Ativamos o redirecionamento de pacotes (requerido para NAT) #####
     echo &quot;1&quot; &gt;/proc/sys/net/ipv4/ip_forward
     
     # O iptables define automaticamente o número máximo de conexões simultâneas 
     # com base na memória do sistema. Para 32MB = 2048, 64MB = 4096, 128MB = 8192, 
     # sendo que são usados 350 bytes de memória residente para controlar 
     # cada conexão. 
     # Quando este limite é excedido a seguinte mensagem é mostrada:
     #  &quot;ip_conntrack: maximum limit of XXX entries exceed&quot;
     #
     # Como temos uma rede simples, vamos abaixar este limite. Por outro lado isto 
     # criará uma certa limitação de tráfego para evitar a sobrecarga do servidor. 
     echo &quot;2048&quot; &gt; /proc/sys/net/ipv4/ip_conntrack_max
     
     
     ###############################################################
     #                      Tabela filter                          #
     ###############################################################
     
     ##### Chain INPUT #####
     # Criamos um chain que será usado para tratar o tráfego vindo da Internet e 
     iptables -N ppp-input
     
     # Aceita todo o tráfego vindo do loopback e indo pro loopback
     iptables -A INPUT -i lo -j ACCEPT
     # Todo tráfego vindo da rede interna também é aceito
     iptables -A INPUT -s 192.168.1.0/24 -i eth0 -j ACCEPT
     
     # Conexões vindas da interface ppp0 são tratadas pelo chain ppp-input
     iptables -A INPUT -i ppp+ -j ppp-input
     
     # Qualquer outra conexão desconhecida é imediatamente registrada e derrubada
     iptables -A INPUT -j LOG --log-prefix &quot;FIREWALL: INPUT &quot;
     iptables -A INPUT -j DROP
     
     
     ##### Chain FORWARD ####
     # Permite redirecionamento de conexões entre as interfaces locais
     # especificadas abaixo. Qualquer tráfego vindo/indo para outras
     # interfaces será bloqueado neste passo
     iptables -A FORWARD -d 192.168.1.0/24 -i ppp+ -o eth0 -j ACCEPT
     iptables -A FORWARD -s 192.168.1.0/24 -i eth0 -o ppp+ -j ACCEPT
     iptables -A FORWARD -j LOG --log-prefix &quot;FIREWALL: FORWARD &quot;
     iptables -A FORWARD -j DROP
     
     
     ##### Chain ppp-input ####
     # Aceitamos todas as mensagens icmp vindas de ppp0 com certa limitação
     # O tráfego de pacotes icmp que superar este limite será bloqueado
     # pela regra &quot;...! ESTABLISHED,RELATED -j DROP&quot; no final do 
     # chain ppp-input
     #
     iptables -A ppp-input -p icmp -m limit --limit 2/s -j ACCEPT
     
     # Primeiro aceitamos o tráfego vindo da Internet para o serviço www (porta 80)
     iptables -A ppp-input -p tcp --dport 80 -j ACCEPT
     
     # A tentativa de acesso externo a estes serviços serão registrados no syslog
     # do sistema e serão bloqueados pela última regra abaixo.
     iptables -A ppp-input -p tcp --dport 21 -j LOG --log-prefix &quot;FIREWALL: ftp &quot;
     iptables -A ppp-input -p tcp --dport 25 -j LOG --log-prefix &quot;FIREWALL: smtp &quot;
     iptables -A ppp-input -p udp --dport 53 -j LOG --log-prefix &quot;FIREWALL: dns &quot;
     iptables -A ppp-input -p tcp --dport 110 -j LOG --log-prefix &quot;FIREWALL: pop3 &quot;
     iptables -A ppp-input -p tcp --dport 113 -j LOG --log-prefix &quot;FIREWALL: identd &quot;
     iptables -A ppp-input -p udp --dport 111 -j LOG --log-prefix &quot;FIREWALL: rpc&quot;
     iptables -A ppp-input -p tcp --dport 111 -j LOG --log-prefix &quot;FIREWALL: rpc&quot;
     iptables -A ppp-input -p tcp --dport 137:139 -j LOG --log-prefix &quot;FIREWALL: samba &quot;
     iptables -A ppp-input -p udp --dport 137:139 -j LOG --log-prefix &quot;FIREWALL: samba &quot;
     # Bloqueia qualquer tentativa de nova conexão de fora para esta máquina
     iptables -A ppp-input -m state --state ! ESTABLISHED,RELATED -j LOG --log-prefix &quot;FIREWALL: ppp-in &quot;
     iptables -A ppp-input -m state --state ! ESTABLISHED,RELATED -j DROP
     # Qualquer outro tipo de tráfego é aceito
     iptables -A ppp-input -j ACCEPT
     
     
     #######################################################
     #                   Tabela nat                        #
     #######################################################
     
     ##### Chain POSTROUTING #####
     # Permite qualquer conexão vinda com destino a lo e rede local para eth0
     iptables -t nat -A POSTROUTING -o lo -j ACCEPT
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j ACCEPT
     
     # Não queremos que usuários tenham acesso direto a www e smtp da rede externa, o 
     # squid e smtpd do firewall devem ser obrigatoriamente usados. Também registramos
     # as tentativas para monitorarmos qual máquina está tentando conectar-se diretamente.
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -p tcp --dport 80 -j LOG --log-prefix &quot;FIREWALL: SNAT-www &quot;
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -p tcp --dport 25 -j LOG --log-prefix &quot;FIREWALL: SNAT-smtp &quot;
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -p tcp --dport 25 -j DROP
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -p tcp --dport 80 -j DROP
     # É feito masquerading dos outros serviços da rede interna indo para a interface 
     # ppp0 
     iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ppp+ -j MASQUERADE
     
     # Qualquer outra origem de tráfego desconhecida indo para eth0 (conexões vindas 
     # de ppp+) são bloqueadas aqui
     iptables -t nat -A POSTROUTING -o eth0 -d 192.168.1.0/24 -j LOG --log-prefix &quot;FIREWALL: SNAT unknown&quot;
     iptables -t nat -A POSTROUTING -o eth0 -d 192.168.1.0/24 -j DROP
     # Quando iniciamos uma conexão ppp, obtermos um endereço classe A (10.x.x.x) e após
     # estabelecida a conexão real, este endereço é modificado. O tráfego indo para 
     # a interface ppp não deverá ser bloqueado. Os bloqueios serão feitos no 
     # chain INPUT da tabela filter
     iptables -t nat -A POSTROUTING -o ppp+ -j ACCEPT
     
     # Registra e bloqueia qualquer outro tipo de tráfego desconhecido
     iptables -t nat -A POSTROUTING -j LOG --log-prefix &quot;FIREWALL: SNAT &quot;
     iptables -t nat -A POSTROUTING -j DROP
     
     
     ###############################################
     #                Tabela mangle                #
     ###############################################
     
     ##### Chain OUTPUT #####
     # Define mínimo de espera para os serviços ftp, telnet, irc e DNS, isto 
     # dará uma melhor sensação de conexão em tempo real e diminuirá o tempo 
     # de espera para conexões que requerem resolução de nomes. 
     iptables -t mangle -A OUTPUT -o ppp+ -p tcp --dport 21 -j TOS --set-tos 0x10
     iptables -t mangle -A OUTPUT -o ppp+ -p tcp --dport 23 -j TOS --set-tos 0x10
     iptables -t mangle -A OUTPUT -o ppp+ -p tcp --dport 6665:6668 -j TOS --set-tos 0x10
     iptables -t mangle -A OUTPUT -o ppp+ -p udp --dport 53 -j TOS --set-tos 0x10
</pre>

<hr>

[ <a href="ch-impr.html">anterior</a> ]
[ <a href="index.html#contents">Conteúdo</a> ]
[ <a href="ch-intro.html">1</a> ]
[ <a href="ch-bas.html">2</a> ]
[ <a href="ch-hardw.html">3</a> ]
[ <a href="ch-rede.html">4</a> ]
[ <a href="ch-cfgrede.html">5</a> ]
[ <a href="ch-log.html">6</a> ]
[ <a href="ch-deb.html">7</a> ]
[ <a href="ch-pers.html">8</a> ]
[ <a href="ch-impr.html">9</a> ]
[ 10 ]
[ <a href="ch-d-contas.html">11</a> ]
[ <a href="ch-s-apache.html">12</a> ]
[ <a href="ch-s-ident.html">13</a> ]
[ <a href="ch-s-telnet.html">14</a> ]
[ <a href="ch-s-ssh.html">15</a> ]
[ <a href="ch-s-pop3.html">16</a> ]
[ <a href="ch-s-cvs.html">17</a> ]
[ <a href="ch-s-samba.html">18</a> ]
[ <a href="ch-d-restr.html">19</a> ]
[ <a href="ch-d-cripto.html">20</a> ]
[ <a href="ch-apend.html">21</a> ]
[ <a href="ch-d-contas.html">próximo</a> ]

<hr>

<p>
Guia Foca GNU/Linux

<address>
Versão 6.40 - segunda, 30 de outubro de 2006<br>
<br>
Gleydson Mazioli da Silva <code><a href="mailto:gleydson@guiafoca.org">gleydson@guiafoca.org</a></code><br>
<br>
</address>

<hr>

</body>

</html>

